diff --git a/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/McpServerFactory.ts b/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/McpServerFactory.ts
new file mode 100644
index 00000000..7b4106ad
--- /dev/null
+++ b/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/McpServerFactory.ts
@@ -0,0 +1,119 @@
+// Factory that creates MCP servers using either fastmcp or official SDK engine
+// Supports seamless switching via MCP_ENGINE environment variable
+
+import { FastMcpServerOptions, createFastMcpServer } from './FastMcpStarter';
+import { SdkMcpServerOptions, createSdkMcpServer } from './SdkMcpStarter';
+import type { IdentityEnv } from '@nuwa-ai/identity-kit';
+
+export interface McpServerOptions extends FastMcpServerOptions, SdkMcpServerOptions {
+  engine?: 'fastmcp' | 'sdk';
+}
+
+export interface McpServerFactory {
+  createServer(opts: McpServerOptions): Promise<{
+    addTool: (def: {
+      name: string;
+      description: string;
+      parameters?: any;
+      execute: (params: any, context?: any) => Promise<any> | any;
+      options?: any;
+    }) => void;
+    freeTool: (def: {
+      name: string;
+      description: string;
+      parameters?: any;
+      execute: (params: any, context?: any) => Promise<any> | any;
+    }) => void;
+    paidTool: (def: {
+      name: string;
+      description: string;
+      pricePicoUSD: bigint;
+      parameters?: any;
+      execute: (params: any, context?: any) => Promise<any> | any;
+    }) => void;
+    addPrompt: (def: {
+      name: string;
+      description: string;
+      arguments?: any[];
+      load: (args: any) => Promise<string> | string;
+    }) => void;
+    addResource: (def: {
+      uri: string;
+      name: string;
+      mimeType: string;
+      load: () => Promise<{ text?: string; blob?: any }> | { text?: string; blob?: any };
+    }) => void;
+    addResourceTemplate: (def: {
+      uriTemplate: string;
+      name: string;
+      mimeType: string;
+      arguments?: any[];
+      load: (args: any) => Promise<{ text?: string; blob?: any }> | { text?: string; blob?: any };
+    }) => void;
+    start: () => Promise<any>;
+    getInner: () => any;
+  }>;
+}
+
+class DefaultMcpServerFactory implements McpServerFactory {
+  async createServer(opts: McpServerOptions) {
+    const engine = opts.engine || this.getEngineFromEnv() || 'fastmcp';
+
+    if (engine === 'sdk') {
+      return createSdkMcpServer(opts);
+    } else {
+      return createFastMcpServer(opts);
+    }
+  }
+
+  private getEngineFromEnv(): 'fastmcp' | 'sdk' | null {
+    const envEngine = process.env.MCP_ENGINE?.toLowerCase();
+    if (envEngine === 'sdk' || envEngine === 'official') {
+      return 'sdk';
+    }
+    if (envEngine === 'fastmcp' || envEngine === 'legacy') {
+      return 'fastmcp';
+    }
+    return null;
+  }
+}
+
+const factory = new DefaultMcpServerFactory();
+
+/**
+ * Create an MCP server using the engine specified by MCP_ENGINE environment variable
+ * or explicit engine option. Default: fastmcp for backwards compatibility.
+ *
+ * Environment variables:
+ * - MCP_ENGINE=fastmcp (default) or MCP_ENGINE=legacy
+ * - MCP_ENGINE=sdk or MCP_ENGINE=official
+ */
+export async function createMcpServer(opts: McpServerOptions) {
+  return factory.createServer(opts);
+}
+
+/**
+ * Convenience: start MCP server using IdentityEnv (env.keyManager + VDR chain config)
+ * Engine selection follows MCP_ENGINE environment variable.
+ */
+export async function createMcpServerFromEnv(
+  env: IdentityEnv,
+  opts: Omit<McpServerOptions, 'signer' | 'rpcUrl' | 'network'>
+) {
+  const engine = opts.engine || process.env.MCP_ENGINE?.toLowerCase() || 'fastmcp';
+
+  if (engine === 'sdk' || engine === 'official') {
+    const { createSdkMcpServerFromEnv } = await import('./SdkMcpStarter');
+    return createSdkMcpServerFromEnv(env, opts);
+  } else {
+    const { createFastMcpServerFromEnv } = await import('./FastMcpStarter');
+    return createFastMcpServerFromEnv(env, opts);
+  }
+}
+
+// Export factory for testing or custom configurations
+export { DefaultMcpServerFactory as McpServerFactoryImpl };
+export { factory as mcpServerFactory };
+
+// Re-export types for convenience
+export type { FastMcpServerOptions, SdkMcpServerOptions };
\ No newline at end of file
diff --git a/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/SdkMcpStarter.ts b/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/SdkMcpStarter.ts
new file mode 100644
index 00000000..55f9c8fc
--- /dev/null
+++ b/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/SdkMcpStarter.ts
@@ -0,0 +1,596 @@
+// MCP Server using official MCP SDK engine
+// Provides drop-in compatibility with FastMcpStarter but uses @modelcontextprotocol/sdk
+
+import { McpPaymentKit, createMcpPaymentKit, McpPaymentKitOptions } from './McpPaymentKit';
+import { z } from 'zod';
+import type { IdentityEnv } from '@nuwa-ai/identity-kit';
+import { getChainConfigFromEnv } from '../../helpers/fromIdentityEnv';
+import type { Server } from 'http';
+import {
+  Server as McpServer,
+  createServer as createMcpServer
+} from '@modelcontextprotocol/sdk/server/index.js';
+import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
+import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
+import {
+  CallToolRequestSchema,
+  GetPromptRequestSchema,
+  ListPromptsRequestSchema,
+  ListResourcesRequestSchema,
+  ListResourceTemplatesRequestSchema,
+  ListToolsRequestSchema,
+  ReadResourceRequestSchema,
+} from '@modelcontextprotocol/sdk/types.js';
+import { extendZodWithNuwaReserved, normalizeToZodObject } from './ToolSchema';
+import { DebugLogger } from '@nuwa-ai/identity-kit';
+import { RouteOptions } from '../express';
+import { createServer as createHttpServer } from 'http';
+import { parse as parseUrl } from 'url';
+
+// Server type with explicit stop method used by tests and callers
+export type StoppableServer = Server & { stop: () => Promise<void> };
+
+export interface SdkMcpServerOptions extends McpPaymentKitOptions {
+  port?: number;
+  endpoint?: `/${string}`;
+  register?: (registrar: PaymentMcpToolRegistrar) => void;
+  wellKnown?: {
+    enabled?: boolean;
+    path?: `/${string}`; // default: '/.well-known/nuwa-payment/info'
+  };
+  customRouteHandler?: (req: any, res: any) => Promise<boolean> | boolean;
+}
+
+/**
+ * Convenience: start SDK MCP server using IdentityEnv (env.keyManager + VDR chain config)
+ */
+export async function createSdkMcpServerFromEnv(
+  env: IdentityEnv,
+  opts: Omit<SdkMcpServerOptions, 'signer' | 'rpcUrl' | 'network'>
+) {
+  const chain = getChainConfigFromEnv(env);
+  return createSdkMcpServer({
+    ...opts,
+    signer: env.keyManager,
+    rpcUrl: chain.rpcUrl,
+    network: chain.network,
+    debug: opts.debug ?? chain.debug,
+  });
+}
+
+export class PaymentMcpToolRegistrar {
+  private started = false;
+  registeredTools: any[] = [];
+  registeredPrompts: any[] = [];
+  registeredResources: any[] = [];
+  registeredResourceTemplates: any[] = [];
+  constructor(
+    private readonly server: McpServer,
+    private readonly kit: McpPaymentKit
+  ) {}
+
+  markStarted(): void {
+    this.started = true;
+  }
+
+  private ensureNotStarted(): void {
+    if (this.started) {
+      throw new Error(
+        'MCP server already started; tool registration is closed. Register tools before start().'
+      );
+    }
+  }
+
+  addTool(args: {
+    name: string;
+    description: string;
+    handler: (params: any, context?: any) => Promise<any>;
+    schema?: any;
+    options?: RouteOptions;
+  }): void {
+    this.ensureNotStarted();
+    const { name, description, handler, schema, options } = args;
+
+    // Register with billing (enables pricing/settlement)
+    this.kit.register(name, options || { pricing: 0n }, handler);
+
+    const paramsSchema = (() => {
+      if (!schema) return undefined;
+      const zodObj = normalizeToZodObject(schema);
+      if (zodObj) return extendZodWithNuwaReserved(zodObj);
+      return undefined;
+    })();
+
+    const toolDef = {
+      name,
+      description,
+      inputSchema: paramsSchema ? zodToJsonSchema(paramsSchema) : undefined,
+    };
+
+    this.registeredTools.push({
+      ...toolDef,
+      handler: async (params: any) => {
+        return await this.kit.invoke(name, params, {});
+      },
+    });
+  }
+
+  freeTool(args: {
+    name: string;
+    description: string;
+    handler: (params: any, context?: any) => Promise<any>;
+    schema?: any;
+  }): void {
+    this.addTool({ ...args, options: { pricing: 0n } });
+  }
+
+  paidTool(args: {
+    name: string;
+    description: string;
+    pricePicoUSD: bigint;
+    handler: (params: any, context?: any) => Promise<any>;
+    schema?: any;
+  }): void {
+    this.addTool({ ...args, options: { pricing: args.pricePicoUSD } });
+  }
+
+  getTools(): any[] {
+    return this.registeredTools.slice();
+  }
+
+  addPrompt(def: {
+    name: string;
+    description: string;
+    arguments?: any[];
+    load: (args: any) => Promise<string> | string;
+  }): void {
+    this.ensureNotStarted();
+    const promptDef = {
+      name: def.name,
+      description: def.description,
+      arguments: def.arguments || [],
+    } as any;
+    this.registeredPrompts.push({
+      ...promptDef,
+      load: def.load,
+    });
+  }
+
+  addResource(def: {
+    uri: string;
+    name: string;
+    mimeType: string;
+    load: () => Promise<{ text?: string; blob?: any }> | { text?: string; blob?: any };
+  }): void {
+    this.ensureNotStarted();
+    const resDef = {
+      uri: def.uri,
+      name: def.name,
+      mimeType: def.mimeType,
+    } as any;
+    this.registeredResources.push({
+      ...resDef,
+      load: def.load,
+    });
+  }
+
+  addResourceTemplate(def: {
+    uriTemplate: string;
+    name: string;
+    mimeType: string;
+    arguments?: any[];
+    load: (args: any) => Promise<{ text?: string; blob?: any }> | { text?: string; blob?: any };
+  }): void {
+    this.ensureNotStarted();
+    const tplDef = {
+      uriTemplate: def.uriTemplate,
+      name: def.name,
+      mimeType: def.mimeType,
+      arguments: def.arguments || [],
+    } as any;
+    this.registeredResourceTemplates.push({
+      ...tplDef,
+      load: def.load,
+    });
+  }
+
+  getPrompts(): any[] {
+    return this.registeredPrompts.slice();
+  }
+  getResources(): any[] {
+    return this.registeredResources.slice();
+  }
+  getResourceTemplates(): any[] {
+    return this.registeredResourceTemplates.slice();
+  }
+}
+
+// Helper to convert Zod schema to JSON Schema
+function zodToJsonSchema(zodSchema: any): any {
+  try {
+    // Import zod-to-json-schema dynamically
+    const { zodToJsonSchema: convert } = require('zod-to-json-schema');
+    return convert(zodSchema);
+  } catch {
+    // Fallback if conversion fails
+    return undefined;
+  }
+}
+
+export async function createSdkMcpServer(opts: SdkMcpServerOptions): Promise<{
+  addTool: (def: {
+    name: string;
+    description: string;
+    parameters?: any;
+    execute: (params: any, context?: any) => Promise<any> | any;
+    options?: RouteOptions;
+  }) => void;
+  freeTool: (def: {
+    name: string;
+    description: string;
+    parameters?: any;
+    execute: (params: any, context?: any) => Promise<any> | any;
+  }) => void;
+  paidTool: (def: {
+    name: string;
+    description: string;
+    pricePicoUSD: bigint;
+    parameters?: any;
+    execute: (params: any, context?: any) => Promise<any> | any;
+  }) => void;
+  addPrompt: (def: {
+    name: string;
+    description: string;
+    arguments?: any[];
+    load: (args: any) => Promise<string> | string;
+  }) => void;
+  addResource: (def: {
+    uri: string;
+    name: string;
+    mimeType: string;
+    load: () => Promise<{ text?: string; blob?: any }> | { text?: string; blob?: any };
+  }) => void;
+  addResourceTemplate: (def: {
+    uriTemplate: string;
+    name: string;
+    mimeType: string;
+    arguments?: any[];
+    load: (args: any) => Promise<{ text?: string; blob?: any }> | { text?: string; blob?: any };
+  }) => void;
+  start: () => Promise<StoppableServer>;
+  getInner: () => { server: McpServer; kit: McpPaymentKit };
+}> {
+  const logger = DebugLogger.get('SdkMcpStarter');
+
+  const server = createMcpServer(
+    {
+      name: opts.serviceId || 'nuwa-mcp-server',
+      version: '1.0.0',
+    },
+    {
+      capabilities: {
+        tools: {},
+        prompts: {},
+        resources: {},
+        resourceTemplates: {},
+      },
+    }
+  );
+
+  const kit = await createMcpPaymentKit(opts);
+
+  // Register built-in payment tools via registrar
+  const bootstrapRegistrar = new PaymentMcpToolRegistrar(server, kit);
+
+  // Register each tool from kit
+  for (const name of kit.listTools()) {
+    const toolDef = {
+      name,
+      description: `Built-in payment tool: ${name}`,
+      inputSchema: undefined, // Use permissive schema
+    };
+
+    bootstrapRegistrar.registeredTools.push({
+      ...toolDef,
+      handler: async (params: any) => {
+        return await kit.invoke(name, params, {});
+      },
+    });
+  }
+
+  const registrar = bootstrapRegistrar;
+
+  // Set up request handlers
+  server.setRequestHandler(ListToolsRequestSchema, async () => {
+    return {
+      tools: registrar.getTools().map(tool => ({
+        name: tool.name,
+        description: tool.description,
+        inputSchema: tool.inputSchema,
+      })),
+    };
+  });
+
+  server.setRequestHandler(CallToolRequestSchema, async (request) => {
+    const { name, arguments: args } = request.params;
+    const tool = registrar.getTools().find(t => t.name === name);
+
+    if (!tool) {
+      throw new Error(`Tool '${name}' not found`);
+    }
+
+    try {
+      const result = await tool.handler(args);
+      return {
+        content: [
+          {
+            type: 'text',
+            text: typeof result === 'string' ? result : JSON.stringify(result),
+          },
+        ],
+      };
+    } catch (error) {
+      throw new Error(`Tool execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
+    }
+  });
+
+  server.setRequestHandler(ListPromptsRequestSchema, async () => {
+    return {
+      prompts: registrar.getPrompts(),
+    };
+  });
+
+  server.setRequestHandler(GetPromptRequestSchema, async (request) => {
+    const { name, arguments: args } = request.params;
+    const prompt = registrar.getPrompts().find((p: any) => p.name === name);
+
+    if (!prompt) {
+      throw new Error(`Prompt '${name}' not found`);
+    }
+
+    const result = await prompt.load(args);
+    return {
+      description: prompt.description,
+      messages: [
+        {
+          role: 'user',
+          content: {
+            type: 'text',
+            text: result,
+          },
+        },
+      ],
+    };
+  });
+
+  server.setRequestHandler(ListResourcesRequestSchema, async () => {
+    return {
+      resources: registrar.getResources(),
+    };
+  });
+
+  server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
+    const { uri } = request.params;
+    const resource = registrar.getResources().find((r: any) => r.uri === uri);
+
+    if (!resource) {
+      throw new Error(`Resource '${uri}' not found`);
+    }
+
+    const result = await resource.load();
+    return {
+      contents: [
+        {
+          uri,
+          mimeType: resource.mimeType,
+          ...result,
+        },
+      ],
+    };
+  });
+
+  server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {
+    return {
+      resourceTemplates: registrar.getResourceTemplates(),
+    };
+  });
+
+  const start = async () => {
+    const port = opts.port ?? 8080;
+    const endpoint = opts.endpoint || '/mcp';
+    const wellKnownEnabled = opts.wellKnown?.enabled !== false;
+    const wellKnownPath = (opts.wellKnown?.path ||
+      '/.well-known/nuwa-payment/info') as `/${string}`;
+
+    const httpServer = createHttpServer((req: any, res: any) => {
+      const url = parseUrl(req.url || '', true);
+
+      // Handle preflight requests
+      if (req.method === 'OPTIONS') {
+        res.writeHead(204);
+        res.end();
+        return;
+      }
+
+      // Health endpoint
+      if (req.method === 'GET' && url.pathname === '/health') {
+        res.writeHead(200, { 'Content-Type': 'text/plain' }).end('âœ“ Ok');
+        return;
+      }
+
+      // Ready endpoint
+      if (req.method === 'GET' && url.pathname === '/ready') {
+        const payload = {
+          ready: 1,
+          status: 'ready',
+          total: 1,
+        };
+        res.writeHead(200, { 'Content-Type': 'application/json' }).end(JSON.stringify(payload));
+        return;
+      }
+
+      // Well-known discovery endpoint
+      if (wellKnownEnabled && req.method === 'GET' && url.pathname === wellKnownPath) {
+        try {
+          const serviceDid = await kit.getServiceDid();
+          const body = {
+            version: 1,
+            serviceId: opts.serviceId || 'nuwa-mcp-server',
+            serviceDid,
+            network: opts.network || 'test',
+            defaultAssetId: opts.defaultAssetId || '0x3::gas_coin::RGas',
+            defaultPricePicoUSD: opts.defaultPricePicoUSD?.toString(),
+            basePath: endpoint,
+          };
+          res.writeHead(200, { 'Content-Type': 'application/json' }).end(JSON.stringify(body));
+        } catch (e: any) {
+          logger.error('Failed to generate service discovery info', {
+            error: e?.message,
+            stack: e?.stack,
+          } as any);
+          res.writeHead(500, { 'Content-Type': 'application/json' })
+            .end(JSON.stringify({ error: e?.message || 'internal error' }));
+        }
+        return;
+      }
+
+      // Try custom route handler
+      if (opts.customRouteHandler) {
+        opts.customRouteHandler(req, res).then((handled) => {
+          if (!handled) {
+            res.writeHead(404).end();
+          }
+        }).catch(() => {
+          res.writeHead(500).end();
+        });
+        return;
+      }
+
+      res.writeHead(404).end();
+    });
+
+    // Set up SSE transport for MCP
+    const sseTransport = new SSEServerTransport('/mcp', res);
+
+    // Connect the MCP server to the SSE transport
+    await server.connect(sseTransport);
+
+    registrar.markStarted();
+
+    logger.debug('registered tools', {
+      tools: registrar.getTools().map(t => t.name),
+      total: registrar.getTools().length,
+    } as any);
+
+    const srv = httpServer as any as StoppableServer;
+    logger.info(`SDK MCP HTTP server listening at http://localhost:${port}`);
+
+    // Wrap stop/close to ensure kit resources are destroyed
+    const originalClose = srv.close?.bind(srv);
+    (srv as any).stop = async () => {
+      try {
+        kit.destroy();
+      } catch {}
+      try {
+        await server.close();
+      } catch {}
+      try {
+        await new Promise<void>((resolve) => {
+          if (typeof originalClose === 'function') {
+            originalClose(() => resolve());
+          } else {
+            resolve();
+          }
+        });
+      } catch {}
+    };
+    return srv;
+  };
+
+  const addTool = (def: {
+    name: string;
+    description: string;
+    parameters?: any;
+    execute: (params: any, context?: any) => Promise<any> | any;
+    options?: RouteOptions;
+  }) => {
+    registrar.addTool({
+      name: def.name,
+      description: def.description,
+      schema: def.parameters,
+      options: def.options,
+      handler: async (params, context) => def.execute(params, context),
+    });
+  };
+
+  const freeTool = (def: {
+    name: string;
+    description: string;
+    parameters?: any;
+    execute: (params: any, context?: any) => Promise<any> | any;
+  }) => {
+    registrar.freeTool({
+      name: def.name,
+      description: def.description,
+      schema: def.parameters,
+      handler: async (params, context) => def.execute(params, context),
+    });
+  };
+
+  const paidTool = (def: {
+    name: string;
+    description: string;
+    pricePicoUSD: bigint;
+    parameters?: any;
+    execute: (params: any, context?: any) => Promise<any> | any;
+  }) => {
+    registrar.paidTool({
+      name: def.name,
+      description: def.description,
+      pricePicoUSD: def.pricePicoUSD,
+      schema: def.parameters,
+      handler: async (params, context) => def.execute(params, context),
+    });
+  };
+
+  const getInner = () => ({ server, kit });
+
+  const addPrompt = (def: {
+    name: string;
+    description: string;
+    arguments?: any[];
+    load: (args: any) => Promise<string> | string;
+  }) => {
+    registrar.addPrompt(def);
+  };
+
+  const addResource = (def: {
+    uri: string;
+    name: string;
+    mimeType: string;
+    load: () => Promise<{ text?: string; blob?: any }> | { text?: string; blob?: any };
+  }) => {
+    registrar.addResource(def);
+  };
+
+  const addResourceTemplate = (def: {
+    uriTemplate: string;
+    name: string;
+    mimeType: string;
+    arguments?: any[];
+    load: (args: any) => Promise<{ text?: string; blob?: any }> | { text?: string; blob?: any };
+  }) => {
+    registrar.addResourceTemplate(def);
+  };
+
+  return {
+    addTool,
+    freeTool,
+    paidTool,
+    addPrompt,
+    addResource,
+    addResourceTemplate,
+    start,
+    getInner,
+  };
+}
\ No newline at end of file
diff --git a/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/index.ts b/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/index.ts
index 2b8645c1..e86032d4 100644
--- a/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/index.ts
+++ b/nuwa-kit/typescript/packages/payment-kit/src/transport/mcp/index.ts
@@ -1,4 +1,6 @@
 // MCP transport layer exports
 export * from './McpPaymentKit';
 export * from './FastMcpStarter';
+export * from './SdkMcpStarter';
+export * from './McpServerFactory';
 export * from '../../middlewares/mcp/McpBillingMiddleware';
diff --git a/nuwa-kit/typescript/packages/payment-kit/test/transport/mcp/McpEngineParity.test.ts b/nuwa-kit/typescript/packages/payment-kit/test/transport/mcp/McpEngineParity.test.ts
new file mode 100644
index 00000000..9fdef8c7
--- /dev/null
+++ b/nuwa-kit/typescript/packages/payment-kit/test/transport/mcp/McpEngineParity.test.ts
@@ -0,0 +1,373 @@
+// Parity tests for FastMcpStarter vs SdkMcpStarter engines
+// Ensures both engines provide identical behavior and API compatibility
+
+import {
+  createFastMcpServer,
+  type FastMcpServerOptions,
+} from '../../../src/transport/mcp/FastMcpStarter';
+import {
+  createSdkMcpServer,
+  type SdkMcpServerOptions,
+} from '../../../src/transport/mcp/SdkMcpStarter';
+import { KeyManager } from '@nuwa-ai/identity-kit';
+import type { McpServerOptions } from '../../../src/transport/mcp/McpServerFactory';
+
+// Mock environment for testing
+const mockSigner = {
+  address: '0x1234567890123456789012345678901234567890',
+  sign: jest.fn(),
+} as any;
+
+const baseServerOptions = {
+  serviceId: 'test-mcp-server',
+  signer: mockSigner,
+  rpcUrl: 'https://test-rpc.com',
+  network: 'test' as const,
+  port: 0, // Random available port
+  endpoint: '/mcp' as const,
+};
+
+describe('MCP Engine Parity Tests', () => {
+  describe('API Compatibility', () => {
+    let fastmcpServer: any;
+    let sdkServer: any;
+
+    afterEach(async () => {
+      try {
+        await fastmcpServer?.stop?.();
+      } catch {}
+      try {
+        await sdkServer?.stop?.();
+      } catch {}
+    });
+
+    test('should have identical return signatures', async () => {
+      fastmcpServer = await createFastMcpServer(baseServerOptions as FastMcpServerOptions);
+      sdkServer = await createSdkMcpServer(baseServerOptions as SdkMcpServerOptions);
+
+      // Both should have the same methods
+      const expectedMethods = [
+        'addTool',
+        'freeTool',
+        'paidTool',
+        'addPrompt',
+        'addResource',
+        'addResourceTemplate',
+        'start',
+        'getInner',
+      ];
+
+      for (const method of expectedMethods) {
+        expect(typeof fastmcpServer[method]).toBe('function');
+        expect(typeof sdkServer[method]).toBe('function');
+      }
+
+      // getInner should return server and kit
+      const fastmcpInner = fastmcpServer.getInner();
+      const sdkInner = sdkServer.getInner();
+
+      expect(fastmcpInner).toHaveProperty('server');
+      expect(fastmcpInner).toHaveProperty('kit');
+      expect(sdkInner).toHaveProperty('server');
+      expect(sdkInner).toHaveProperty('kit');
+    });
+
+    test('should handle tool registration consistently', async () => {
+      fastmcpServer = await createFastMcpServer(baseServerOptions as FastMcpServerOptions);
+      sdkServer = await createSdkMcpServer(baseServerOptions as SdkMcpServerOptions);
+
+      const toolDef = {
+        name: 'test_tool',
+        description: 'Test tool for parity',
+        parameters: {
+          type: 'object',
+          properties: {
+            message: { type: 'string' },
+          },
+        },
+        execute: jest.fn().mockResolvedValue({ result: 'success' }),
+      };
+
+      // Both should register tools without errors
+      expect(() => {
+        fastmcpServer.addTool(toolDef);
+      }).not.toThrow();
+
+      expect(() => {
+        sdkServer.addTool(toolDef);
+      }).not.toThrow();
+
+      // Test free tool registration
+      const freeToolDef = {
+        name: 'free_tool',
+        description: 'Free tool test',
+        parameters: {
+          type: 'object',
+          properties: {
+            data: { type: 'string' },
+          },
+        },
+        execute: jest.fn().mockResolvedValue({ free: 'yes' }),
+      };
+
+      expect(() => {
+        fastmcpServer.freeTool(freeToolDef);
+      }).not.toThrow();
+
+      expect(() => {
+        sdkServer.freeTool(freeToolDef);
+      }).not.toThrow();
+
+      // Test paid tool registration
+      const paidToolDef = {
+        name: 'paid_tool',
+        description: 'Paid tool test',
+        pricePicoUSD: 1000n,
+        parameters: {
+          type: 'object',
+          properties: {
+            query: { type: 'string' },
+          },
+        },
+        execute: jest.fn().mockResolvedValue({ paid: 'yes' }),
+      };
+
+      expect(() => {
+        fastmcpServer.paidTool(paidToolDef);
+      }).not.toThrow();
+
+      expect(() => {
+        sdkServer.paidTool(paidToolDef);
+      }).not.toThrow();
+    });
+
+    test('should handle prompt registration consistently', async () => {
+      fastmcpServer = await createFastMcpServer(baseServerOptions as FastMcpServerOptions);
+      sdkServer = await createSdkMcpServer(baseServerOptions as SdkMcpServerOptions);
+
+      const promptDef = {
+        name: 'test_prompt',
+        description: 'Test prompt for parity',
+        arguments: [
+          {
+            name: 'context',
+            description: 'Context for the prompt',
+            required: false,
+          },
+        ],
+        load: jest.fn().mockResolvedValue('Test prompt content'),
+      };
+
+      expect(() => {
+        fastmcpServer.addPrompt(promptDef);
+      }).not.toThrow();
+
+      expect(() => {
+        sdkServer.addPrompt(promptDef);
+      }).not.toThrow();
+    });
+
+    test('should handle resource registration consistently', async () => {
+      fastmcpServer = await createFastMcpServer(baseServerOptions as FastMcpServerOptions);
+      sdkServer = await createSdkMcpServer(baseServerOptions as SdkMcpServerOptions);
+
+      const resourceDef = {
+        uri: 'test://resource',
+        name: 'Test Resource',
+        mimeType: 'text/plain',
+        load: jest.fn().mockResolvedValue({ text: 'Test resource content' }),
+      };
+
+      expect(() => {
+        fastmcpServer.addResource(resourceDef);
+      }).not.toThrow();
+
+      expect(() => {
+        sdkServer.addResource(resourceDef);
+      }).not.toThrow();
+
+      const templateDef = {
+        uriTemplate: 'test://template/{param}',
+        name: 'Test Template',
+        mimeType: 'application/json',
+        arguments: [
+          {
+            name: 'param',
+            description: 'Template parameter',
+            required: true,
+          },
+        ],
+        load: jest.fn().mockResolvedValue({ text: JSON.stringify({ param: 'test' }) }),
+      };
+
+      expect(() => {
+        fastmcpServer.addResourceTemplate(templateDef);
+      }).not.toThrow();
+
+      expect(() => {
+        sdkServer.addResourceTemplate(templateDef);
+      }).not.toThrow();
+    });
+  });
+
+  describe('Configuration Handling', () => {
+    test('should handle wellKnown configuration', async () => {
+      const optionsWithWellKnown = {
+        ...baseServerOptions,
+        wellKnown: {
+          enabled: true,
+          path: '/custom-well-known' as const,
+        },
+      };
+
+      let fastmcpServer = await createFastMcpServer(optionsWithWellKnown as FastMcpServerOptions);
+      let sdkServer = await createSdkMcpServer(optionsWithWellKnown as SdkMcpServerOptions);
+
+      expect(fastmcpServer).toBeDefined();
+      expect(sdkServer).toBeDefined();
+
+      await fastmcpServer.stop?.();
+      await sdkServer.stop?.();
+    });
+
+    test('should handle custom route handlers', async () => {
+      const customHandler = jest.fn().mockResolvedValue(true);
+
+      const optionsWithHandler = {
+        ...baseServerOptions,
+        customRouteHandler,
+      };
+
+      let fastmcpServer = await createFastMcpServer(optionsWithHandler as FastMcpServerOptions);
+      let sdkServer = await createSdkMcpServer(optionsWithHandler as SdkMcpServerOptions);
+
+      expect(fastmcpServer).toBeDefined();
+      expect(sdkServer).toBeDefined();
+
+      await fastmcpServer.stop?.();
+      await sdkServer.stop?.();
+    });
+  });
+
+  describe('Built-in Payment Tools', () => {
+    test('should register built-in payment tools', async () => {
+      let fastmcpServer = await createFastMcpServer(baseServerOptions as FastMcpServerOptions);
+      let sdkServer = await createSdkMcpServer(baseServerOptions as SdkMcpServerOptions);
+
+      const fastmcpInner = fastmcpServer.getInner();
+      const sdkInner = sdkServer.getInner();
+
+      // Both should have kits with built-in tools
+      expect(fastmcpInner.kit).toBeDefined();
+      expect(sdkInner.kit).toBeDefined();
+      expect(typeof fastmcpInner.kit.listTools).toBe('function');
+      expect(typeof sdkInner.kit.listTools).toBe('function');
+
+      const fastmcpTools = fastmcpInner.kit.listTools();
+      const sdkTools = sdkInner.kit.listTools();
+
+      expect(Array.isArray(fastmcpTools)).toBe(true);
+      expect(Array.isArray(sdkTools)).toBe(true);
+      expect(fastmcpTools.length).toBeGreaterThan(0);
+      expect(sdkTools.length).toBeGreaterThan(0);
+
+      await fastmcpServer.stop?.();
+      await sdkServer.stop?.();
+    });
+  });
+});
+
+describe('McpServerFactory Integration', () => {
+  const originalEnv = process.env;
+
+  beforeEach(() => {
+    jest.resetModules();
+    delete process.env.MCP_ENGINE;
+  });
+
+  afterEach(() => {
+    process.env = originalEnv;
+  });
+
+  test('should use fastmcp engine by default', async () => {
+    const { createMcpServer } = await import('../../../src/transport/mcp/McpServerFactory');
+
+    const server = await createMcpServer(baseServerOptions as McpServerOptions);
+    expect(server).toBeDefined();
+    await server.stop?.();
+  });
+
+  test('should use fastmcp engine when MCP_ENGINE=fastmcp', async () => {
+    process.env.MCP_ENGINE = 'fastmcp';
+    const { createMcpServer } = await import('../../../src/transport/mcp/McpServerFactory');
+
+    const server = await createMcpServer(baseServerOptions as McpServerOptions);
+    expect(server).toBeDefined();
+    await server.stop?.();
+  });
+
+  test('should use fastmcp engine when MCP_ENGINE=legacy', async () => {
+    process.env.MCP_ENGINE = 'legacy';
+    const { createMcpServer } = await import('../../../src/transport/mcp/McpServerFactory');
+
+    const server = await createMcpServer(baseServerOptions as McpServerOptions);
+    expect(server).toBeDefined();
+    await server.stop?.();
+  });
+
+  test('should use sdk engine when MCP_ENGINE=sdk', async () => {
+    process.env.MCP_ENGINE = 'sdk';
+    const { createMcpServer } = await import('../../../src/transport/mcp/McpServerFactory');
+
+    const server = await createMcpServer(baseServerOptions as McpServerOptions);
+    expect(server).toBeDefined();
+    await server.stop?.();
+  });
+
+  test('should use sdk engine when MCP_ENGINE=official', async () => {
+    process.env.MCP_ENGINE = 'official';
+    const { createMcpServer } = await import('../../../src/transport/mcp/McpServerFactory');
+
+    const server = await createMcpServer(baseServerOptions as McpServerOptions);
+    expect(server).toBeDefined();
+    await server.stop?.();
+  });
+
+  test('should override environment variable with explicit engine option', async () => {
+    process.env.MCP_ENGINE = 'fastmcp';
+    const { createMcpServer } = await import('../../../src/transport/mcp/McpServerFactory');
+
+    const server = await createMcpServer({
+      ...baseServerOptions,
+      engine: 'sdk',
+    } as McpServerOptions);
+
+    expect(server).toBeDefined();
+    await server.stop?.();
+  });
+});
+
+describe('Environment Variable Support', () => {
+  test('should respect MCP_ENGINE environment variable', () => {
+    // Test that the factory correctly reads the environment variable
+    const engineValues = ['fastmcp', 'legacy', 'sdk', 'official'];
+
+    for (const engine of engineValues) {
+      process.env.MCP_ENGINE = engine;
+
+      // Dynamic import to get fresh module state
+      jest.resetModules();
+      const { DefaultMcpServerFactory } = require('../../../src/transport/mcp/McpServerFactory');
+
+      const factory = new DefaultMcpServerFactory();
+      const expectedEngine = (engine === 'sdk' || engine === 'official') ? 'sdk' : 'fastmcp';
+
+      // Test internal method through reflection for testing purposes
+      const getEngineFromEnv = factory['getEngineFromEnv']?.bind(factory);
+      if (getEngineFromEnv) {
+        const result = getEngineFromEnv();
+        expect(result).toBe(expectedEngine === 'fastmcp' ? 'fastmcp' : 'sdk');
+      }
+    }
+  });
+});
\ No newline at end of file
diff --git a/nuwa-services/mcp-server-proxy/src/server.ts b/nuwa-services/mcp-server-proxy/src/server.ts
index 72dc1845..95f42c7e 100644
--- a/nuwa-services/mcp-server-proxy/src/server.ts
+++ b/nuwa-services/mcp-server-proxy/src/server.ts
@@ -1,18 +1,19 @@
 /**
- * MCP Server v2 - Start via FastMcpStarter (handles MCP over HTTP/SSE)
+ * MCP Server v2 - Start via McpServerFactory (handles MCP over HTTP/SSE)
+ * Supports both fastmcp (default) and official SDK engines via MCP_ENGINE env var
  */
 import { KeyManager } from '@nuwa-ai/identity-kit';
-import { createFastMcpServer } from '@nuwa-ai/payment-kit';
+import { createMcpServer } from '@nuwa-ai/payment-kit';
 import { initUpstream } from './upstream.js';
 import type { Upstream } from './types.js';
 import { loadConfig, type MinimalConfig, type MinimalToolConfig } from './config.js';
 import { z } from 'zod';
 
-// Local registry removed; FastMcpStarter manages tools
+// Local registry removed; McpServerFactory manages tools
 
-// No Fastify server; FastMcpStarter provides HTTP server
+// No Fastify server; McpServerFactory provides HTTP server
 
-// (FastMcpStarter handles HTTP/SSE/MCP parsing)
+// (McpServerFactory handles HTTP/SSE/MCP parsing via selected engine)
 
 // Exported function to start the server (for testing and direct use)
 async function startServer(
@@ -126,17 +127,17 @@ async function startServer(
             });
             console.log(`Upstream response for ${upstreamTool.name}:`, res);
             if (res && Array.isArray(res.content)) {
-              // Return the content array directly so FastMcpStarter can handle it properly
+              // Return the content array directly so the MCP engine can handle it properly
               return { content: res.content };
             }
             return res;
           };
 
-          // Use FastMcpStarter's tool registration mechanism which handles schema conversion
+          // Use McpServerFactory's tool registration mechanism which handles schema conversion
           const upstreamToolDef = {
             name: upstreamTool.name,
             description: upstreamTool.description || `Forwarded tool: ${upstreamTool.name}`,
-            // Pass the original inputSchema - FastMcpStarter will handle the conversion
+            // Pass the original inputSchema - the MCP engine will handle the conversion
             parameters: upstreamTool.inputSchema,
             execute: forwardExecute,
           };
