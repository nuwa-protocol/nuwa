Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> script
Rule 1     script -> statements
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> let_statement
Rule 5     statement -> call_statement
Rule 6     statement -> if_statement
Rule 7     statement -> for_statement
Rule 8     let_statement -> LET ID ASSIGN expression
Rule 9     call_statement -> CALL ID LBRACE arguments RBRACE
Rule 10    if_statement -> IF expression THEN statements END
Rule 11    if_statement -> IF expression THEN statements ELSE statements END
Rule 12    for_statement -> FOR ID IN expression DO statements END
Rule 13    arguments -> argument_list
Rule 14    arguments -> empty
Rule 15    argument_list -> argument_list COMMA argument
Rule 16    argument_list -> argument
Rule 17    argument -> ID COLON expression
Rule 18    empty -> <empty>
Rule 19    expression -> binary_op
Rule 20    expression -> unary_op
Rule 21    expression -> function_call
Rule 22    expression -> call_expression
Rule 23    expression -> calc_expression
Rule 24    expression -> literal
Rule 25    expression -> variable
Rule 26    expression -> LPAREN expression RPAREN
Rule 27    binary_op -> expression EQ expression
Rule 28    binary_op -> expression NE expression
Rule 29    binary_op -> expression LT expression
Rule 30    binary_op -> expression LE expression
Rule 31    binary_op -> expression GT expression
Rule 32    binary_op -> expression GE expression
Rule 33    binary_op -> expression AND expression
Rule 34    binary_op -> expression OR expression
Rule 35    binary_op -> expression DOT ID
Rule 36    unary_op -> NOT expression
Rule 37    function_call -> NOW LPAREN RPAREN
Rule 38    call_expression -> CALL ID LBRACE arguments RBRACE
Rule 39    calc_expression -> CALC LBRACE calc_args RBRACE
Rule 40    calc_args -> ID COLON STRING COMMA ID COLON LBRACE arguments RBRACE
Rule 41    literal -> NUMBER
Rule 42    literal -> STRING
Rule 43    literal -> BOOLEAN
Rule 44    variable -> ID

Terminals, with rules where they appear

AND                  : 33
ASSIGN               : 8
BOOLEAN              : 43
CALC                 : 39
CALL                 : 9 38
COLON                : 17 40 40
COMMA                : 15 40
DO                   : 12
DOT                  : 35
ELSE                 : 11
END                  : 10 11 12
EQ                   : 27
FOR                  : 12
GE                   : 32
GT                   : 31
ID                   : 8 9 12 17 35 38 40 40 44
IF                   : 10 11
IN                   : 12
LBRACE               : 9 38 39 40
LE                   : 30
LET                  : 8
LPAREN               : 26 37
LT                   : 29
NE                   : 28
NOT                  : 36
NOW                  : 37
NUMBER               : 41
OR                   : 34
RBRACE               : 9 38 39 40
RPAREN               : 26 37
STRING               : 40 42
THEN                 : 10 11
error                : 

Nonterminals, with rules where they appear

argument             : 15 16
argument_list        : 13 15
arguments            : 9 38 40
binary_op            : 19
calc_args            : 39
calc_expression      : 23
call_expression      : 22
call_statement       : 5
empty                : 14
expression           : 8 10 11 12 17 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 36
for_statement        : 7
function_call        : 21
if_statement         : 6
let_statement        : 4
literal              : 24
script               : 0
statement            : 2 3
statements           : 1 2 10 11 11 12
unary_op             : 20
variable             : 25

Parsing method: LALR

state 0

    (0) S' -> . script
    (1) script -> . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) let_statement -> . LET ID ASSIGN expression
    (9) call_statement -> . CALL ID LBRACE arguments RBRACE
    (10) if_statement -> . IF expression THEN statements END
    (11) if_statement -> . IF expression THEN statements ELSE statements END
    (12) for_statement -> . FOR ID IN expression DO statements END

    LET             shift and go to state 8
    CALL            shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11

    script                         shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7

state 1

    (0) S' -> script .



state 2

    (1) script -> statements .
    (2) statements -> statements . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) let_statement -> . LET ID ASSIGN expression
    (9) call_statement -> . CALL ID LBRACE arguments RBRACE
    (10) if_statement -> . IF expression THEN statements END
    (11) if_statement -> . IF expression THEN statements ELSE statements END
    (12) for_statement -> . FOR ID IN expression DO statements END

    $end            reduce using rule 1 (script -> statements .)
    LET             shift and go to state 8
    CALL            shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11

    statement                      shift and go to state 12
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7

state 3

    (3) statements -> statement .

    LET             reduce using rule 3 (statements -> statement .)
    CALL            reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    $end            reduce using rule 3 (statements -> statement .)
    END             reduce using rule 3 (statements -> statement .)
    ELSE            reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> let_statement .

    LET             reduce using rule 4 (statement -> let_statement .)
    CALL            reduce using rule 4 (statement -> let_statement .)
    IF              reduce using rule 4 (statement -> let_statement .)
    FOR             reduce using rule 4 (statement -> let_statement .)
    $end            reduce using rule 4 (statement -> let_statement .)
    END             reduce using rule 4 (statement -> let_statement .)
    ELSE            reduce using rule 4 (statement -> let_statement .)


state 5

    (5) statement -> call_statement .

    LET             reduce using rule 5 (statement -> call_statement .)
    CALL            reduce using rule 5 (statement -> call_statement .)
    IF              reduce using rule 5 (statement -> call_statement .)
    FOR             reduce using rule 5 (statement -> call_statement .)
    $end            reduce using rule 5 (statement -> call_statement .)
    END             reduce using rule 5 (statement -> call_statement .)
    ELSE            reduce using rule 5 (statement -> call_statement .)


state 6

    (6) statement -> if_statement .

    LET             reduce using rule 6 (statement -> if_statement .)
    CALL            reduce using rule 6 (statement -> if_statement .)
    IF              reduce using rule 6 (statement -> if_statement .)
    FOR             reduce using rule 6 (statement -> if_statement .)
    $end            reduce using rule 6 (statement -> if_statement .)
    END             reduce using rule 6 (statement -> if_statement .)
    ELSE            reduce using rule 6 (statement -> if_statement .)


state 7

    (7) statement -> for_statement .

    LET             reduce using rule 7 (statement -> for_statement .)
    CALL            reduce using rule 7 (statement -> for_statement .)
    IF              reduce using rule 7 (statement -> for_statement .)
    FOR             reduce using rule 7 (statement -> for_statement .)
    $end            reduce using rule 7 (statement -> for_statement .)
    END             reduce using rule 7 (statement -> for_statement .)
    ELSE            reduce using rule 7 (statement -> for_statement .)


state 8

    (8) let_statement -> LET . ID ASSIGN expression

    ID              shift and go to state 13


state 9

    (9) call_statement -> CALL . ID LBRACE arguments RBRACE

    ID              shift and go to state 14


state 10

    (10) if_statement -> IF . expression THEN statements END
    (11) if_statement -> IF . expression THEN statements ELSE statements END
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 15
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 11

    (12) for_statement -> FOR . ID IN expression DO statements END

    ID              shift and go to state 32


state 12

    (2) statements -> statements statement .

    LET             reduce using rule 2 (statements -> statements statement .)
    CALL            reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    FOR             reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)
    END             reduce using rule 2 (statements -> statements statement .)
    ELSE            reduce using rule 2 (statements -> statements statement .)


state 13

    (8) let_statement -> LET ID . ASSIGN expression

    ASSIGN          shift and go to state 33


state 14

    (9) call_statement -> CALL ID . LBRACE arguments RBRACE

    LBRACE          shift and go to state 34


state 15

    (10) if_statement -> IF expression . THEN statements END
    (11) if_statement -> IF expression . THEN statements ELSE statements END
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            shift and go to state 35
    EQ              shift and go to state 36
    NE              shift and go to state 37
    LT              shift and go to state 38
    LE              shift and go to state 39
    GT              shift and go to state 40
    GE              shift and go to state 41
    AND             shift and go to state 42
    OR              shift and go to state 43
    DOT             shift and go to state 44


state 16

    (19) expression -> binary_op .

    THEN            reduce using rule 19 (expression -> binary_op .)
    EQ              reduce using rule 19 (expression -> binary_op .)
    NE              reduce using rule 19 (expression -> binary_op .)
    LT              reduce using rule 19 (expression -> binary_op .)
    LE              reduce using rule 19 (expression -> binary_op .)
    GT              reduce using rule 19 (expression -> binary_op .)
    GE              reduce using rule 19 (expression -> binary_op .)
    AND             reduce using rule 19 (expression -> binary_op .)
    OR              reduce using rule 19 (expression -> binary_op .)
    DOT             reduce using rule 19 (expression -> binary_op .)
    RPAREN          reduce using rule 19 (expression -> binary_op .)
    LET             reduce using rule 19 (expression -> binary_op .)
    CALL            reduce using rule 19 (expression -> binary_op .)
    IF              reduce using rule 19 (expression -> binary_op .)
    FOR             reduce using rule 19 (expression -> binary_op .)
    $end            reduce using rule 19 (expression -> binary_op .)
    END             reduce using rule 19 (expression -> binary_op .)
    ELSE            reduce using rule 19 (expression -> binary_op .)
    DO              reduce using rule 19 (expression -> binary_op .)
    COMMA           reduce using rule 19 (expression -> binary_op .)
    RBRACE          reduce using rule 19 (expression -> binary_op .)


state 17

    (20) expression -> unary_op .

    THEN            reduce using rule 20 (expression -> unary_op .)
    EQ              reduce using rule 20 (expression -> unary_op .)
    NE              reduce using rule 20 (expression -> unary_op .)
    LT              reduce using rule 20 (expression -> unary_op .)
    LE              reduce using rule 20 (expression -> unary_op .)
    GT              reduce using rule 20 (expression -> unary_op .)
    GE              reduce using rule 20 (expression -> unary_op .)
    AND             reduce using rule 20 (expression -> unary_op .)
    OR              reduce using rule 20 (expression -> unary_op .)
    DOT             reduce using rule 20 (expression -> unary_op .)
    RPAREN          reduce using rule 20 (expression -> unary_op .)
    LET             reduce using rule 20 (expression -> unary_op .)
    CALL            reduce using rule 20 (expression -> unary_op .)
    IF              reduce using rule 20 (expression -> unary_op .)
    FOR             reduce using rule 20 (expression -> unary_op .)
    $end            reduce using rule 20 (expression -> unary_op .)
    END             reduce using rule 20 (expression -> unary_op .)
    ELSE            reduce using rule 20 (expression -> unary_op .)
    DO              reduce using rule 20 (expression -> unary_op .)
    COMMA           reduce using rule 20 (expression -> unary_op .)
    RBRACE          reduce using rule 20 (expression -> unary_op .)


state 18

    (21) expression -> function_call .

    THEN            reduce using rule 21 (expression -> function_call .)
    EQ              reduce using rule 21 (expression -> function_call .)
    NE              reduce using rule 21 (expression -> function_call .)
    LT              reduce using rule 21 (expression -> function_call .)
    LE              reduce using rule 21 (expression -> function_call .)
    GT              reduce using rule 21 (expression -> function_call .)
    GE              reduce using rule 21 (expression -> function_call .)
    AND             reduce using rule 21 (expression -> function_call .)
    OR              reduce using rule 21 (expression -> function_call .)
    DOT             reduce using rule 21 (expression -> function_call .)
    RPAREN          reduce using rule 21 (expression -> function_call .)
    LET             reduce using rule 21 (expression -> function_call .)
    CALL            reduce using rule 21 (expression -> function_call .)
    IF              reduce using rule 21 (expression -> function_call .)
    FOR             reduce using rule 21 (expression -> function_call .)
    $end            reduce using rule 21 (expression -> function_call .)
    END             reduce using rule 21 (expression -> function_call .)
    ELSE            reduce using rule 21 (expression -> function_call .)
    DO              reduce using rule 21 (expression -> function_call .)
    COMMA           reduce using rule 21 (expression -> function_call .)
    RBRACE          reduce using rule 21 (expression -> function_call .)


state 19

    (22) expression -> call_expression .

    THEN            reduce using rule 22 (expression -> call_expression .)
    EQ              reduce using rule 22 (expression -> call_expression .)
    NE              reduce using rule 22 (expression -> call_expression .)
    LT              reduce using rule 22 (expression -> call_expression .)
    LE              reduce using rule 22 (expression -> call_expression .)
    GT              reduce using rule 22 (expression -> call_expression .)
    GE              reduce using rule 22 (expression -> call_expression .)
    AND             reduce using rule 22 (expression -> call_expression .)
    OR              reduce using rule 22 (expression -> call_expression .)
    DOT             reduce using rule 22 (expression -> call_expression .)
    RPAREN          reduce using rule 22 (expression -> call_expression .)
    LET             reduce using rule 22 (expression -> call_expression .)
    CALL            reduce using rule 22 (expression -> call_expression .)
    IF              reduce using rule 22 (expression -> call_expression .)
    FOR             reduce using rule 22 (expression -> call_expression .)
    $end            reduce using rule 22 (expression -> call_expression .)
    END             reduce using rule 22 (expression -> call_expression .)
    ELSE            reduce using rule 22 (expression -> call_expression .)
    DO              reduce using rule 22 (expression -> call_expression .)
    COMMA           reduce using rule 22 (expression -> call_expression .)
    RBRACE          reduce using rule 22 (expression -> call_expression .)


state 20

    (23) expression -> calc_expression .

    THEN            reduce using rule 23 (expression -> calc_expression .)
    EQ              reduce using rule 23 (expression -> calc_expression .)
    NE              reduce using rule 23 (expression -> calc_expression .)
    LT              reduce using rule 23 (expression -> calc_expression .)
    LE              reduce using rule 23 (expression -> calc_expression .)
    GT              reduce using rule 23 (expression -> calc_expression .)
    GE              reduce using rule 23 (expression -> calc_expression .)
    AND             reduce using rule 23 (expression -> calc_expression .)
    OR              reduce using rule 23 (expression -> calc_expression .)
    DOT             reduce using rule 23 (expression -> calc_expression .)
    RPAREN          reduce using rule 23 (expression -> calc_expression .)
    LET             reduce using rule 23 (expression -> calc_expression .)
    CALL            reduce using rule 23 (expression -> calc_expression .)
    IF              reduce using rule 23 (expression -> calc_expression .)
    FOR             reduce using rule 23 (expression -> calc_expression .)
    $end            reduce using rule 23 (expression -> calc_expression .)
    END             reduce using rule 23 (expression -> calc_expression .)
    ELSE            reduce using rule 23 (expression -> calc_expression .)
    DO              reduce using rule 23 (expression -> calc_expression .)
    COMMA           reduce using rule 23 (expression -> calc_expression .)
    RBRACE          reduce using rule 23 (expression -> calc_expression .)


state 21

    (24) expression -> literal .

    THEN            reduce using rule 24 (expression -> literal .)
    EQ              reduce using rule 24 (expression -> literal .)
    NE              reduce using rule 24 (expression -> literal .)
    LT              reduce using rule 24 (expression -> literal .)
    LE              reduce using rule 24 (expression -> literal .)
    GT              reduce using rule 24 (expression -> literal .)
    GE              reduce using rule 24 (expression -> literal .)
    AND             reduce using rule 24 (expression -> literal .)
    OR              reduce using rule 24 (expression -> literal .)
    DOT             reduce using rule 24 (expression -> literal .)
    RPAREN          reduce using rule 24 (expression -> literal .)
    LET             reduce using rule 24 (expression -> literal .)
    CALL            reduce using rule 24 (expression -> literal .)
    IF              reduce using rule 24 (expression -> literal .)
    FOR             reduce using rule 24 (expression -> literal .)
    $end            reduce using rule 24 (expression -> literal .)
    END             reduce using rule 24 (expression -> literal .)
    ELSE            reduce using rule 24 (expression -> literal .)
    DO              reduce using rule 24 (expression -> literal .)
    COMMA           reduce using rule 24 (expression -> literal .)
    RBRACE          reduce using rule 24 (expression -> literal .)


state 22

    (25) expression -> variable .

    THEN            reduce using rule 25 (expression -> variable .)
    EQ              reduce using rule 25 (expression -> variable .)
    NE              reduce using rule 25 (expression -> variable .)
    LT              reduce using rule 25 (expression -> variable .)
    LE              reduce using rule 25 (expression -> variable .)
    GT              reduce using rule 25 (expression -> variable .)
    GE              reduce using rule 25 (expression -> variable .)
    AND             reduce using rule 25 (expression -> variable .)
    OR              reduce using rule 25 (expression -> variable .)
    DOT             reduce using rule 25 (expression -> variable .)
    RPAREN          reduce using rule 25 (expression -> variable .)
    LET             reduce using rule 25 (expression -> variable .)
    CALL            reduce using rule 25 (expression -> variable .)
    IF              reduce using rule 25 (expression -> variable .)
    FOR             reduce using rule 25 (expression -> variable .)
    $end            reduce using rule 25 (expression -> variable .)
    END             reduce using rule 25 (expression -> variable .)
    ELSE            reduce using rule 25 (expression -> variable .)
    DO              reduce using rule 25 (expression -> variable .)
    COMMA           reduce using rule 25 (expression -> variable .)
    RBRACE          reduce using rule 25 (expression -> variable .)


state 23

    (26) expression -> LPAREN . expression RPAREN
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 45
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 24

    (44) variable -> ID .

    THEN            reduce using rule 44 (variable -> ID .)
    EQ              reduce using rule 44 (variable -> ID .)
    NE              reduce using rule 44 (variable -> ID .)
    LT              reduce using rule 44 (variable -> ID .)
    LE              reduce using rule 44 (variable -> ID .)
    GT              reduce using rule 44 (variable -> ID .)
    GE              reduce using rule 44 (variable -> ID .)
    AND             reduce using rule 44 (variable -> ID .)
    OR              reduce using rule 44 (variable -> ID .)
    DOT             reduce using rule 44 (variable -> ID .)
    RPAREN          reduce using rule 44 (variable -> ID .)
    LET             reduce using rule 44 (variable -> ID .)
    CALL            reduce using rule 44 (variable -> ID .)
    IF              reduce using rule 44 (variable -> ID .)
    FOR             reduce using rule 44 (variable -> ID .)
    $end            reduce using rule 44 (variable -> ID .)
    END             reduce using rule 44 (variable -> ID .)
    ELSE            reduce using rule 44 (variable -> ID .)
    DO              reduce using rule 44 (variable -> ID .)
    COMMA           reduce using rule 44 (variable -> ID .)
    RBRACE          reduce using rule 44 (variable -> ID .)


state 25

    (36) unary_op -> NOT . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 46
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 26

    (37) function_call -> NOW . LPAREN RPAREN

    LPAREN          shift and go to state 47


state 27

    (38) call_expression -> CALL . ID LBRACE arguments RBRACE

    ID              shift and go to state 48


state 28

    (39) calc_expression -> CALC . LBRACE calc_args RBRACE

    LBRACE          shift and go to state 49


state 29

    (41) literal -> NUMBER .

    THEN            reduce using rule 41 (literal -> NUMBER .)
    EQ              reduce using rule 41 (literal -> NUMBER .)
    NE              reduce using rule 41 (literal -> NUMBER .)
    LT              reduce using rule 41 (literal -> NUMBER .)
    LE              reduce using rule 41 (literal -> NUMBER .)
    GT              reduce using rule 41 (literal -> NUMBER .)
    GE              reduce using rule 41 (literal -> NUMBER .)
    AND             reduce using rule 41 (literal -> NUMBER .)
    OR              reduce using rule 41 (literal -> NUMBER .)
    DOT             reduce using rule 41 (literal -> NUMBER .)
    RPAREN          reduce using rule 41 (literal -> NUMBER .)
    LET             reduce using rule 41 (literal -> NUMBER .)
    CALL            reduce using rule 41 (literal -> NUMBER .)
    IF              reduce using rule 41 (literal -> NUMBER .)
    FOR             reduce using rule 41 (literal -> NUMBER .)
    $end            reduce using rule 41 (literal -> NUMBER .)
    END             reduce using rule 41 (literal -> NUMBER .)
    ELSE            reduce using rule 41 (literal -> NUMBER .)
    DO              reduce using rule 41 (literal -> NUMBER .)
    COMMA           reduce using rule 41 (literal -> NUMBER .)
    RBRACE          reduce using rule 41 (literal -> NUMBER .)


state 30

    (42) literal -> STRING .

    THEN            reduce using rule 42 (literal -> STRING .)
    EQ              reduce using rule 42 (literal -> STRING .)
    NE              reduce using rule 42 (literal -> STRING .)
    LT              reduce using rule 42 (literal -> STRING .)
    LE              reduce using rule 42 (literal -> STRING .)
    GT              reduce using rule 42 (literal -> STRING .)
    GE              reduce using rule 42 (literal -> STRING .)
    AND             reduce using rule 42 (literal -> STRING .)
    OR              reduce using rule 42 (literal -> STRING .)
    DOT             reduce using rule 42 (literal -> STRING .)
    RPAREN          reduce using rule 42 (literal -> STRING .)
    LET             reduce using rule 42 (literal -> STRING .)
    CALL            reduce using rule 42 (literal -> STRING .)
    IF              reduce using rule 42 (literal -> STRING .)
    FOR             reduce using rule 42 (literal -> STRING .)
    $end            reduce using rule 42 (literal -> STRING .)
    END             reduce using rule 42 (literal -> STRING .)
    ELSE            reduce using rule 42 (literal -> STRING .)
    DO              reduce using rule 42 (literal -> STRING .)
    COMMA           reduce using rule 42 (literal -> STRING .)
    RBRACE          reduce using rule 42 (literal -> STRING .)


state 31

    (43) literal -> BOOLEAN .

    THEN            reduce using rule 43 (literal -> BOOLEAN .)
    EQ              reduce using rule 43 (literal -> BOOLEAN .)
    NE              reduce using rule 43 (literal -> BOOLEAN .)
    LT              reduce using rule 43 (literal -> BOOLEAN .)
    LE              reduce using rule 43 (literal -> BOOLEAN .)
    GT              reduce using rule 43 (literal -> BOOLEAN .)
    GE              reduce using rule 43 (literal -> BOOLEAN .)
    AND             reduce using rule 43 (literal -> BOOLEAN .)
    OR              reduce using rule 43 (literal -> BOOLEAN .)
    DOT             reduce using rule 43 (literal -> BOOLEAN .)
    RPAREN          reduce using rule 43 (literal -> BOOLEAN .)
    LET             reduce using rule 43 (literal -> BOOLEAN .)
    CALL            reduce using rule 43 (literal -> BOOLEAN .)
    IF              reduce using rule 43 (literal -> BOOLEAN .)
    FOR             reduce using rule 43 (literal -> BOOLEAN .)
    $end            reduce using rule 43 (literal -> BOOLEAN .)
    END             reduce using rule 43 (literal -> BOOLEAN .)
    ELSE            reduce using rule 43 (literal -> BOOLEAN .)
    DO              reduce using rule 43 (literal -> BOOLEAN .)
    COMMA           reduce using rule 43 (literal -> BOOLEAN .)
    RBRACE          reduce using rule 43 (literal -> BOOLEAN .)


state 32

    (12) for_statement -> FOR ID . IN expression DO statements END

    IN              shift and go to state 50


state 33

    (8) let_statement -> LET ID ASSIGN . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 51
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 34

    (9) call_statement -> CALL ID LBRACE . arguments RBRACE
    (13) arguments -> . argument_list
    (14) arguments -> . empty
    (15) argument_list -> . argument_list COMMA argument
    (16) argument_list -> . argument
    (18) empty -> .
    (17) argument -> . ID COLON expression

    RBRACE          reduce using rule 18 (empty -> .)
    ID              shift and go to state 52

    arguments                      shift and go to state 53
    argument_list                  shift and go to state 54
    empty                          shift and go to state 55
    argument                       shift and go to state 56

state 35

    (10) if_statement -> IF expression THEN . statements END
    (11) if_statement -> IF expression THEN . statements ELSE statements END
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) let_statement -> . LET ID ASSIGN expression
    (9) call_statement -> . CALL ID LBRACE arguments RBRACE
    (10) if_statement -> . IF expression THEN statements END
    (11) if_statement -> . IF expression THEN statements ELSE statements END
    (12) for_statement -> . FOR ID IN expression DO statements END

    LET             shift and go to state 8
    CALL            shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11

    statements                     shift and go to state 57
    statement                      shift and go to state 3
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7

state 36

    (27) binary_op -> expression EQ . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 58
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 37

    (28) binary_op -> expression NE . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 59
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 38

    (29) binary_op -> expression LT . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 60
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 39

    (30) binary_op -> expression LE . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 61
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 40

    (31) binary_op -> expression GT . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 62
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 41

    (32) binary_op -> expression GE . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 63
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 42

    (33) binary_op -> expression AND . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 64
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 43

    (34) binary_op -> expression OR . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 65
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 44

    (35) binary_op -> expression DOT . ID

    ID              shift and go to state 66


state 45

    (26) expression -> LPAREN expression . RPAREN
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    RPAREN          shift and go to state 67
    EQ              shift and go to state 36
    NE              shift and go to state 37
    LT              shift and go to state 38
    LE              shift and go to state 39
    GT              shift and go to state 40
    GE              shift and go to state 41
    AND             shift and go to state 42
    OR              shift and go to state 43
    DOT             shift and go to state 44


state 46

    (36) unary_op -> NOT expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            reduce using rule 36 (unary_op -> NOT expression .)
    AND             reduce using rule 36 (unary_op -> NOT expression .)
    OR              reduce using rule 36 (unary_op -> NOT expression .)
    DOT             reduce using rule 36 (unary_op -> NOT expression .)
    RPAREN          reduce using rule 36 (unary_op -> NOT expression .)
    LET             reduce using rule 36 (unary_op -> NOT expression .)
    CALL            reduce using rule 36 (unary_op -> NOT expression .)
    IF              reduce using rule 36 (unary_op -> NOT expression .)
    FOR             reduce using rule 36 (unary_op -> NOT expression .)
    $end            reduce using rule 36 (unary_op -> NOT expression .)
    END             reduce using rule 36 (unary_op -> NOT expression .)
    ELSE            reduce using rule 36 (unary_op -> NOT expression .)
    DO              reduce using rule 36 (unary_op -> NOT expression .)
    COMMA           reduce using rule 36 (unary_op -> NOT expression .)
    RBRACE          reduce using rule 36 (unary_op -> NOT expression .)
    EQ              shift and go to state 36
    NE              shift and go to state 37
    LT              shift and go to state 38
    LE              shift and go to state 39
    GT              shift and go to state 40
    GE              shift and go to state 41

  ! EQ              [ reduce using rule 36 (unary_op -> NOT expression .) ]
  ! NE              [ reduce using rule 36 (unary_op -> NOT expression .) ]
  ! LT              [ reduce using rule 36 (unary_op -> NOT expression .) ]
  ! LE              [ reduce using rule 36 (unary_op -> NOT expression .) ]
  ! GT              [ reduce using rule 36 (unary_op -> NOT expression .) ]
  ! GE              [ reduce using rule 36 (unary_op -> NOT expression .) ]
  ! AND             [ shift and go to state 42 ]
  ! OR              [ shift and go to state 43 ]
  ! DOT             [ shift and go to state 44 ]


state 47

    (37) function_call -> NOW LPAREN . RPAREN

    RPAREN          shift and go to state 68


state 48

    (38) call_expression -> CALL ID . LBRACE arguments RBRACE

    LBRACE          shift and go to state 69


state 49

    (39) calc_expression -> CALC LBRACE . calc_args RBRACE
    (40) calc_args -> . ID COLON STRING COMMA ID COLON LBRACE arguments RBRACE

    ID              shift and go to state 71

    calc_args                      shift and go to state 70

state 50

    (12) for_statement -> FOR ID IN . expression DO statements END
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 72
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 51

    (8) let_statement -> LET ID ASSIGN expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    LET             reduce using rule 8 (let_statement -> LET ID ASSIGN expression .)
    CALL            reduce using rule 8 (let_statement -> LET ID ASSIGN expression .)
    IF              reduce using rule 8 (let_statement -> LET ID ASSIGN expression .)
    FOR             reduce using rule 8 (let_statement -> LET ID ASSIGN expression .)
    $end            reduce using rule 8 (let_statement -> LET ID ASSIGN expression .)
    END             reduce using rule 8 (let_statement -> LET ID ASSIGN expression .)
    ELSE            reduce using rule 8 (let_statement -> LET ID ASSIGN expression .)
    EQ              shift and go to state 36
    NE              shift and go to state 37
    LT              shift and go to state 38
    LE              shift and go to state 39
    GT              shift and go to state 40
    GE              shift and go to state 41
    AND             shift and go to state 42
    OR              shift and go to state 43
    DOT             shift and go to state 44


state 52

    (17) argument -> ID . COLON expression

    COLON           shift and go to state 73


state 53

    (9) call_statement -> CALL ID LBRACE arguments . RBRACE

    RBRACE          shift and go to state 74


state 54

    (13) arguments -> argument_list .
    (15) argument_list -> argument_list . COMMA argument

    RBRACE          reduce using rule 13 (arguments -> argument_list .)
    COMMA           shift and go to state 75


state 55

    (14) arguments -> empty .

    RBRACE          reduce using rule 14 (arguments -> empty .)


state 56

    (16) argument_list -> argument .

    COMMA           reduce using rule 16 (argument_list -> argument .)
    RBRACE          reduce using rule 16 (argument_list -> argument .)


state 57

    (10) if_statement -> IF expression THEN statements . END
    (11) if_statement -> IF expression THEN statements . ELSE statements END
    (2) statements -> statements . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) let_statement -> . LET ID ASSIGN expression
    (9) call_statement -> . CALL ID LBRACE arguments RBRACE
    (10) if_statement -> . IF expression THEN statements END
    (11) if_statement -> . IF expression THEN statements ELSE statements END
    (12) for_statement -> . FOR ID IN expression DO statements END

    END             shift and go to state 76
    ELSE            shift and go to state 77
    LET             shift and go to state 8
    CALL            shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11

    statement                      shift and go to state 12
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7

state 58

    (27) binary_op -> expression EQ expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            reduce using rule 27 (binary_op -> expression EQ expression .)
    EQ              reduce using rule 27 (binary_op -> expression EQ expression .)
    NE              reduce using rule 27 (binary_op -> expression EQ expression .)
    LT              reduce using rule 27 (binary_op -> expression EQ expression .)
    LE              reduce using rule 27 (binary_op -> expression EQ expression .)
    GT              reduce using rule 27 (binary_op -> expression EQ expression .)
    GE              reduce using rule 27 (binary_op -> expression EQ expression .)
    AND             reduce using rule 27 (binary_op -> expression EQ expression .)
    OR              reduce using rule 27 (binary_op -> expression EQ expression .)
    DOT             reduce using rule 27 (binary_op -> expression EQ expression .)
    RPAREN          reduce using rule 27 (binary_op -> expression EQ expression .)
    LET             reduce using rule 27 (binary_op -> expression EQ expression .)
    CALL            reduce using rule 27 (binary_op -> expression EQ expression .)
    IF              reduce using rule 27 (binary_op -> expression EQ expression .)
    FOR             reduce using rule 27 (binary_op -> expression EQ expression .)
    $end            reduce using rule 27 (binary_op -> expression EQ expression .)
    END             reduce using rule 27 (binary_op -> expression EQ expression .)
    ELSE            reduce using rule 27 (binary_op -> expression EQ expression .)
    DO              reduce using rule 27 (binary_op -> expression EQ expression .)
    COMMA           reduce using rule 27 (binary_op -> expression EQ expression .)
    RBRACE          reduce using rule 27 (binary_op -> expression EQ expression .)

  ! EQ              [ shift and go to state 36 ]
  ! NE              [ shift and go to state 37 ]
  ! LT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 39 ]
  ! GT              [ shift and go to state 40 ]
  ! GE              [ shift and go to state 41 ]
  ! AND             [ shift and go to state 42 ]
  ! OR              [ shift and go to state 43 ]
  ! DOT             [ shift and go to state 44 ]


state 59

    (28) binary_op -> expression NE expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            reduce using rule 28 (binary_op -> expression NE expression .)
    EQ              reduce using rule 28 (binary_op -> expression NE expression .)
    NE              reduce using rule 28 (binary_op -> expression NE expression .)
    LT              reduce using rule 28 (binary_op -> expression NE expression .)
    LE              reduce using rule 28 (binary_op -> expression NE expression .)
    GT              reduce using rule 28 (binary_op -> expression NE expression .)
    GE              reduce using rule 28 (binary_op -> expression NE expression .)
    AND             reduce using rule 28 (binary_op -> expression NE expression .)
    OR              reduce using rule 28 (binary_op -> expression NE expression .)
    DOT             reduce using rule 28 (binary_op -> expression NE expression .)
    RPAREN          reduce using rule 28 (binary_op -> expression NE expression .)
    LET             reduce using rule 28 (binary_op -> expression NE expression .)
    CALL            reduce using rule 28 (binary_op -> expression NE expression .)
    IF              reduce using rule 28 (binary_op -> expression NE expression .)
    FOR             reduce using rule 28 (binary_op -> expression NE expression .)
    $end            reduce using rule 28 (binary_op -> expression NE expression .)
    END             reduce using rule 28 (binary_op -> expression NE expression .)
    ELSE            reduce using rule 28 (binary_op -> expression NE expression .)
    DO              reduce using rule 28 (binary_op -> expression NE expression .)
    COMMA           reduce using rule 28 (binary_op -> expression NE expression .)
    RBRACE          reduce using rule 28 (binary_op -> expression NE expression .)

  ! EQ              [ shift and go to state 36 ]
  ! NE              [ shift and go to state 37 ]
  ! LT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 39 ]
  ! GT              [ shift and go to state 40 ]
  ! GE              [ shift and go to state 41 ]
  ! AND             [ shift and go to state 42 ]
  ! OR              [ shift and go to state 43 ]
  ! DOT             [ shift and go to state 44 ]


state 60

    (29) binary_op -> expression LT expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            reduce using rule 29 (binary_op -> expression LT expression .)
    EQ              reduce using rule 29 (binary_op -> expression LT expression .)
    NE              reduce using rule 29 (binary_op -> expression LT expression .)
    LT              reduce using rule 29 (binary_op -> expression LT expression .)
    LE              reduce using rule 29 (binary_op -> expression LT expression .)
    GT              reduce using rule 29 (binary_op -> expression LT expression .)
    GE              reduce using rule 29 (binary_op -> expression LT expression .)
    AND             reduce using rule 29 (binary_op -> expression LT expression .)
    OR              reduce using rule 29 (binary_op -> expression LT expression .)
    DOT             reduce using rule 29 (binary_op -> expression LT expression .)
    RPAREN          reduce using rule 29 (binary_op -> expression LT expression .)
    LET             reduce using rule 29 (binary_op -> expression LT expression .)
    CALL            reduce using rule 29 (binary_op -> expression LT expression .)
    IF              reduce using rule 29 (binary_op -> expression LT expression .)
    FOR             reduce using rule 29 (binary_op -> expression LT expression .)
    $end            reduce using rule 29 (binary_op -> expression LT expression .)
    END             reduce using rule 29 (binary_op -> expression LT expression .)
    ELSE            reduce using rule 29 (binary_op -> expression LT expression .)
    DO              reduce using rule 29 (binary_op -> expression LT expression .)
    COMMA           reduce using rule 29 (binary_op -> expression LT expression .)
    RBRACE          reduce using rule 29 (binary_op -> expression LT expression .)

  ! EQ              [ shift and go to state 36 ]
  ! NE              [ shift and go to state 37 ]
  ! LT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 39 ]
  ! GT              [ shift and go to state 40 ]
  ! GE              [ shift and go to state 41 ]
  ! AND             [ shift and go to state 42 ]
  ! OR              [ shift and go to state 43 ]
  ! DOT             [ shift and go to state 44 ]


state 61

    (30) binary_op -> expression LE expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            reduce using rule 30 (binary_op -> expression LE expression .)
    EQ              reduce using rule 30 (binary_op -> expression LE expression .)
    NE              reduce using rule 30 (binary_op -> expression LE expression .)
    LT              reduce using rule 30 (binary_op -> expression LE expression .)
    LE              reduce using rule 30 (binary_op -> expression LE expression .)
    GT              reduce using rule 30 (binary_op -> expression LE expression .)
    GE              reduce using rule 30 (binary_op -> expression LE expression .)
    AND             reduce using rule 30 (binary_op -> expression LE expression .)
    OR              reduce using rule 30 (binary_op -> expression LE expression .)
    DOT             reduce using rule 30 (binary_op -> expression LE expression .)
    RPAREN          reduce using rule 30 (binary_op -> expression LE expression .)
    LET             reduce using rule 30 (binary_op -> expression LE expression .)
    CALL            reduce using rule 30 (binary_op -> expression LE expression .)
    IF              reduce using rule 30 (binary_op -> expression LE expression .)
    FOR             reduce using rule 30 (binary_op -> expression LE expression .)
    $end            reduce using rule 30 (binary_op -> expression LE expression .)
    END             reduce using rule 30 (binary_op -> expression LE expression .)
    ELSE            reduce using rule 30 (binary_op -> expression LE expression .)
    DO              reduce using rule 30 (binary_op -> expression LE expression .)
    COMMA           reduce using rule 30 (binary_op -> expression LE expression .)
    RBRACE          reduce using rule 30 (binary_op -> expression LE expression .)

  ! EQ              [ shift and go to state 36 ]
  ! NE              [ shift and go to state 37 ]
  ! LT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 39 ]
  ! GT              [ shift and go to state 40 ]
  ! GE              [ shift and go to state 41 ]
  ! AND             [ shift and go to state 42 ]
  ! OR              [ shift and go to state 43 ]
  ! DOT             [ shift and go to state 44 ]


state 62

    (31) binary_op -> expression GT expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            reduce using rule 31 (binary_op -> expression GT expression .)
    EQ              reduce using rule 31 (binary_op -> expression GT expression .)
    NE              reduce using rule 31 (binary_op -> expression GT expression .)
    LT              reduce using rule 31 (binary_op -> expression GT expression .)
    LE              reduce using rule 31 (binary_op -> expression GT expression .)
    GT              reduce using rule 31 (binary_op -> expression GT expression .)
    GE              reduce using rule 31 (binary_op -> expression GT expression .)
    AND             reduce using rule 31 (binary_op -> expression GT expression .)
    OR              reduce using rule 31 (binary_op -> expression GT expression .)
    DOT             reduce using rule 31 (binary_op -> expression GT expression .)
    RPAREN          reduce using rule 31 (binary_op -> expression GT expression .)
    LET             reduce using rule 31 (binary_op -> expression GT expression .)
    CALL            reduce using rule 31 (binary_op -> expression GT expression .)
    IF              reduce using rule 31 (binary_op -> expression GT expression .)
    FOR             reduce using rule 31 (binary_op -> expression GT expression .)
    $end            reduce using rule 31 (binary_op -> expression GT expression .)
    END             reduce using rule 31 (binary_op -> expression GT expression .)
    ELSE            reduce using rule 31 (binary_op -> expression GT expression .)
    DO              reduce using rule 31 (binary_op -> expression GT expression .)
    COMMA           reduce using rule 31 (binary_op -> expression GT expression .)
    RBRACE          reduce using rule 31 (binary_op -> expression GT expression .)

  ! EQ              [ shift and go to state 36 ]
  ! NE              [ shift and go to state 37 ]
  ! LT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 39 ]
  ! GT              [ shift and go to state 40 ]
  ! GE              [ shift and go to state 41 ]
  ! AND             [ shift and go to state 42 ]
  ! OR              [ shift and go to state 43 ]
  ! DOT             [ shift and go to state 44 ]


state 63

    (32) binary_op -> expression GE expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            reduce using rule 32 (binary_op -> expression GE expression .)
    EQ              reduce using rule 32 (binary_op -> expression GE expression .)
    NE              reduce using rule 32 (binary_op -> expression GE expression .)
    LT              reduce using rule 32 (binary_op -> expression GE expression .)
    LE              reduce using rule 32 (binary_op -> expression GE expression .)
    GT              reduce using rule 32 (binary_op -> expression GE expression .)
    GE              reduce using rule 32 (binary_op -> expression GE expression .)
    AND             reduce using rule 32 (binary_op -> expression GE expression .)
    OR              reduce using rule 32 (binary_op -> expression GE expression .)
    DOT             reduce using rule 32 (binary_op -> expression GE expression .)
    RPAREN          reduce using rule 32 (binary_op -> expression GE expression .)
    LET             reduce using rule 32 (binary_op -> expression GE expression .)
    CALL            reduce using rule 32 (binary_op -> expression GE expression .)
    IF              reduce using rule 32 (binary_op -> expression GE expression .)
    FOR             reduce using rule 32 (binary_op -> expression GE expression .)
    $end            reduce using rule 32 (binary_op -> expression GE expression .)
    END             reduce using rule 32 (binary_op -> expression GE expression .)
    ELSE            reduce using rule 32 (binary_op -> expression GE expression .)
    DO              reduce using rule 32 (binary_op -> expression GE expression .)
    COMMA           reduce using rule 32 (binary_op -> expression GE expression .)
    RBRACE          reduce using rule 32 (binary_op -> expression GE expression .)

  ! EQ              [ shift and go to state 36 ]
  ! NE              [ shift and go to state 37 ]
  ! LT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 39 ]
  ! GT              [ shift and go to state 40 ]
  ! GE              [ shift and go to state 41 ]
  ! AND             [ shift and go to state 42 ]
  ! OR              [ shift and go to state 43 ]
  ! DOT             [ shift and go to state 44 ]


state 64

    (33) binary_op -> expression AND expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            reduce using rule 33 (binary_op -> expression AND expression .)
    AND             reduce using rule 33 (binary_op -> expression AND expression .)
    OR              reduce using rule 33 (binary_op -> expression AND expression .)
    DOT             reduce using rule 33 (binary_op -> expression AND expression .)
    RPAREN          reduce using rule 33 (binary_op -> expression AND expression .)
    LET             reduce using rule 33 (binary_op -> expression AND expression .)
    CALL            reduce using rule 33 (binary_op -> expression AND expression .)
    IF              reduce using rule 33 (binary_op -> expression AND expression .)
    FOR             reduce using rule 33 (binary_op -> expression AND expression .)
    $end            reduce using rule 33 (binary_op -> expression AND expression .)
    END             reduce using rule 33 (binary_op -> expression AND expression .)
    ELSE            reduce using rule 33 (binary_op -> expression AND expression .)
    DO              reduce using rule 33 (binary_op -> expression AND expression .)
    COMMA           reduce using rule 33 (binary_op -> expression AND expression .)
    RBRACE          reduce using rule 33 (binary_op -> expression AND expression .)
    EQ              shift and go to state 36
    NE              shift and go to state 37
    LT              shift and go to state 38
    LE              shift and go to state 39
    GT              shift and go to state 40
    GE              shift and go to state 41

  ! EQ              [ reduce using rule 33 (binary_op -> expression AND expression .) ]
  ! NE              [ reduce using rule 33 (binary_op -> expression AND expression .) ]
  ! LT              [ reduce using rule 33 (binary_op -> expression AND expression .) ]
  ! LE              [ reduce using rule 33 (binary_op -> expression AND expression .) ]
  ! GT              [ reduce using rule 33 (binary_op -> expression AND expression .) ]
  ! GE              [ reduce using rule 33 (binary_op -> expression AND expression .) ]
  ! AND             [ shift and go to state 42 ]
  ! OR              [ shift and go to state 43 ]
  ! DOT             [ shift and go to state 44 ]


state 65

    (34) binary_op -> expression OR expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    THEN            reduce using rule 34 (binary_op -> expression OR expression .)
    OR              reduce using rule 34 (binary_op -> expression OR expression .)
    DOT             reduce using rule 34 (binary_op -> expression OR expression .)
    RPAREN          reduce using rule 34 (binary_op -> expression OR expression .)
    LET             reduce using rule 34 (binary_op -> expression OR expression .)
    CALL            reduce using rule 34 (binary_op -> expression OR expression .)
    IF              reduce using rule 34 (binary_op -> expression OR expression .)
    FOR             reduce using rule 34 (binary_op -> expression OR expression .)
    $end            reduce using rule 34 (binary_op -> expression OR expression .)
    END             reduce using rule 34 (binary_op -> expression OR expression .)
    ELSE            reduce using rule 34 (binary_op -> expression OR expression .)
    DO              reduce using rule 34 (binary_op -> expression OR expression .)
    COMMA           reduce using rule 34 (binary_op -> expression OR expression .)
    RBRACE          reduce using rule 34 (binary_op -> expression OR expression .)
    EQ              shift and go to state 36
    NE              shift and go to state 37
    LT              shift and go to state 38
    LE              shift and go to state 39
    GT              shift and go to state 40
    GE              shift and go to state 41
    AND             shift and go to state 42

  ! EQ              [ reduce using rule 34 (binary_op -> expression OR expression .) ]
  ! NE              [ reduce using rule 34 (binary_op -> expression OR expression .) ]
  ! LT              [ reduce using rule 34 (binary_op -> expression OR expression .) ]
  ! LE              [ reduce using rule 34 (binary_op -> expression OR expression .) ]
  ! GT              [ reduce using rule 34 (binary_op -> expression OR expression .) ]
  ! GE              [ reduce using rule 34 (binary_op -> expression OR expression .) ]
  ! AND             [ reduce using rule 34 (binary_op -> expression OR expression .) ]
  ! OR              [ shift and go to state 43 ]
  ! DOT             [ shift and go to state 44 ]


state 66

    (35) binary_op -> expression DOT ID .

    THEN            reduce using rule 35 (binary_op -> expression DOT ID .)
    EQ              reduce using rule 35 (binary_op -> expression DOT ID .)
    NE              reduce using rule 35 (binary_op -> expression DOT ID .)
    LT              reduce using rule 35 (binary_op -> expression DOT ID .)
    LE              reduce using rule 35 (binary_op -> expression DOT ID .)
    GT              reduce using rule 35 (binary_op -> expression DOT ID .)
    GE              reduce using rule 35 (binary_op -> expression DOT ID .)
    AND             reduce using rule 35 (binary_op -> expression DOT ID .)
    OR              reduce using rule 35 (binary_op -> expression DOT ID .)
    DOT             reduce using rule 35 (binary_op -> expression DOT ID .)
    RPAREN          reduce using rule 35 (binary_op -> expression DOT ID .)
    LET             reduce using rule 35 (binary_op -> expression DOT ID .)
    CALL            reduce using rule 35 (binary_op -> expression DOT ID .)
    IF              reduce using rule 35 (binary_op -> expression DOT ID .)
    FOR             reduce using rule 35 (binary_op -> expression DOT ID .)
    $end            reduce using rule 35 (binary_op -> expression DOT ID .)
    END             reduce using rule 35 (binary_op -> expression DOT ID .)
    ELSE            reduce using rule 35 (binary_op -> expression DOT ID .)
    DO              reduce using rule 35 (binary_op -> expression DOT ID .)
    COMMA           reduce using rule 35 (binary_op -> expression DOT ID .)
    RBRACE          reduce using rule 35 (binary_op -> expression DOT ID .)


state 67

    (26) expression -> LPAREN expression RPAREN .

    THEN            reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    DOT             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    LET             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    CALL            reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    FOR             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    END             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    DO              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 26 (expression -> LPAREN expression RPAREN .)


state 68

    (37) function_call -> NOW LPAREN RPAREN .

    THEN            reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    EQ              reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    NE              reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    LT              reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    LE              reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    GT              reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    GE              reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    AND             reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    OR              reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    DOT             reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    RPAREN          reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    LET             reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    CALL            reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    IF              reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    FOR             reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    $end            reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    END             reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    ELSE            reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    DO              reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    COMMA           reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)
    RBRACE          reduce using rule 37 (function_call -> NOW LPAREN RPAREN .)


state 69

    (38) call_expression -> CALL ID LBRACE . arguments RBRACE
    (13) arguments -> . argument_list
    (14) arguments -> . empty
    (15) argument_list -> . argument_list COMMA argument
    (16) argument_list -> . argument
    (18) empty -> .
    (17) argument -> . ID COLON expression

    RBRACE          reduce using rule 18 (empty -> .)
    ID              shift and go to state 52

    arguments                      shift and go to state 78
    argument_list                  shift and go to state 54
    empty                          shift and go to state 55
    argument                       shift and go to state 56

state 70

    (39) calc_expression -> CALC LBRACE calc_args . RBRACE

    RBRACE          shift and go to state 79


state 71

    (40) calc_args -> ID . COLON STRING COMMA ID COLON LBRACE arguments RBRACE

    COLON           shift and go to state 80


state 72

    (12) for_statement -> FOR ID IN expression . DO statements END
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    DO              shift and go to state 81
    EQ              shift and go to state 36
    NE              shift and go to state 37
    LT              shift and go to state 38
    LE              shift and go to state 39
    GT              shift and go to state 40
    GE              shift and go to state 41
    AND             shift and go to state 42
    OR              shift and go to state 43
    DOT             shift and go to state 44


state 73

    (17) argument -> ID COLON . expression
    (19) expression -> . binary_op
    (20) expression -> . unary_op
    (21) expression -> . function_call
    (22) expression -> . call_expression
    (23) expression -> . calc_expression
    (24) expression -> . literal
    (25) expression -> . variable
    (26) expression -> . LPAREN expression RPAREN
    (27) binary_op -> . expression EQ expression
    (28) binary_op -> . expression NE expression
    (29) binary_op -> . expression LT expression
    (30) binary_op -> . expression LE expression
    (31) binary_op -> . expression GT expression
    (32) binary_op -> . expression GE expression
    (33) binary_op -> . expression AND expression
    (34) binary_op -> . expression OR expression
    (35) binary_op -> . expression DOT ID
    (36) unary_op -> . NOT expression
    (37) function_call -> . NOW LPAREN RPAREN
    (38) call_expression -> . CALL ID LBRACE arguments RBRACE
    (39) calc_expression -> . CALC LBRACE calc_args RBRACE
    (41) literal -> . NUMBER
    (42) literal -> . STRING
    (43) literal -> . BOOLEAN
    (44) variable -> . ID

    LPAREN          shift and go to state 23
    NOT             shift and go to state 25
    NOW             shift and go to state 26
    CALL            shift and go to state 27
    CALC            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 24

    expression                     shift and go to state 82
    binary_op                      shift and go to state 16
    unary_op                       shift and go to state 17
    function_call                  shift and go to state 18
    call_expression                shift and go to state 19
    calc_expression                shift and go to state 20
    literal                        shift and go to state 21
    variable                       shift and go to state 22

state 74

    (9) call_statement -> CALL ID LBRACE arguments RBRACE .

    LET             reduce using rule 9 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    CALL            reduce using rule 9 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    IF              reduce using rule 9 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    FOR             reduce using rule 9 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    $end            reduce using rule 9 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    END             reduce using rule 9 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    ELSE            reduce using rule 9 (call_statement -> CALL ID LBRACE arguments RBRACE .)


state 75

    (15) argument_list -> argument_list COMMA . argument
    (17) argument -> . ID COLON expression

    ID              shift and go to state 52

    argument                       shift and go to state 83

state 76

    (10) if_statement -> IF expression THEN statements END .

    LET             reduce using rule 10 (if_statement -> IF expression THEN statements END .)
    CALL            reduce using rule 10 (if_statement -> IF expression THEN statements END .)
    IF              reduce using rule 10 (if_statement -> IF expression THEN statements END .)
    FOR             reduce using rule 10 (if_statement -> IF expression THEN statements END .)
    $end            reduce using rule 10 (if_statement -> IF expression THEN statements END .)
    END             reduce using rule 10 (if_statement -> IF expression THEN statements END .)
    ELSE            reduce using rule 10 (if_statement -> IF expression THEN statements END .)


state 77

    (11) if_statement -> IF expression THEN statements ELSE . statements END
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) let_statement -> . LET ID ASSIGN expression
    (9) call_statement -> . CALL ID LBRACE arguments RBRACE
    (10) if_statement -> . IF expression THEN statements END
    (11) if_statement -> . IF expression THEN statements ELSE statements END
    (12) for_statement -> . FOR ID IN expression DO statements END

    LET             shift and go to state 8
    CALL            shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11

    statements                     shift and go to state 84
    statement                      shift and go to state 3
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7

state 78

    (38) call_expression -> CALL ID LBRACE arguments . RBRACE

    RBRACE          shift and go to state 85


state 79

    (39) calc_expression -> CALC LBRACE calc_args RBRACE .

    THEN            reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    EQ              reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    NE              reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    LT              reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    LE              reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    GT              reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    GE              reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    AND             reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    OR              reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    DOT             reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    RPAREN          reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    LET             reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    CALL            reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    IF              reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    FOR             reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    $end            reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    END             reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    ELSE            reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    DO              reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    COMMA           reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    RBRACE          reduce using rule 39 (calc_expression -> CALC LBRACE calc_args RBRACE .)


state 80

    (40) calc_args -> ID COLON . STRING COMMA ID COLON LBRACE arguments RBRACE

    STRING          shift and go to state 86


state 81

    (12) for_statement -> FOR ID IN expression DO . statements END
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) let_statement -> . LET ID ASSIGN expression
    (9) call_statement -> . CALL ID LBRACE arguments RBRACE
    (10) if_statement -> . IF expression THEN statements END
    (11) if_statement -> . IF expression THEN statements ELSE statements END
    (12) for_statement -> . FOR ID IN expression DO statements END

    LET             shift and go to state 8
    CALL            shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11

    statements                     shift and go to state 87
    statement                      shift and go to state 3
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7

state 82

    (17) argument -> ID COLON expression .
    (27) binary_op -> expression . EQ expression
    (28) binary_op -> expression . NE expression
    (29) binary_op -> expression . LT expression
    (30) binary_op -> expression . LE expression
    (31) binary_op -> expression . GT expression
    (32) binary_op -> expression . GE expression
    (33) binary_op -> expression . AND expression
    (34) binary_op -> expression . OR expression
    (35) binary_op -> expression . DOT ID

    COMMA           reduce using rule 17 (argument -> ID COLON expression .)
    RBRACE          reduce using rule 17 (argument -> ID COLON expression .)
    EQ              shift and go to state 36
    NE              shift and go to state 37
    LT              shift and go to state 38
    LE              shift and go to state 39
    GT              shift and go to state 40
    GE              shift and go to state 41
    AND             shift and go to state 42
    OR              shift and go to state 43
    DOT             shift and go to state 44


state 83

    (15) argument_list -> argument_list COMMA argument .

    COMMA           reduce using rule 15 (argument_list -> argument_list COMMA argument .)
    RBRACE          reduce using rule 15 (argument_list -> argument_list COMMA argument .)


state 84

    (11) if_statement -> IF expression THEN statements ELSE statements . END
    (2) statements -> statements . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) let_statement -> . LET ID ASSIGN expression
    (9) call_statement -> . CALL ID LBRACE arguments RBRACE
    (10) if_statement -> . IF expression THEN statements END
    (11) if_statement -> . IF expression THEN statements ELSE statements END
    (12) for_statement -> . FOR ID IN expression DO statements END

    END             shift and go to state 88
    LET             shift and go to state 8
    CALL            shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11

    statement                      shift and go to state 12
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7

state 85

    (38) call_expression -> CALL ID LBRACE arguments RBRACE .

    THEN            reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    EQ              reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    NE              reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    LT              reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    LE              reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    GT              reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    GE              reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    AND             reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    OR              reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    DOT             reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    RPAREN          reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    LET             reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    CALL            reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    IF              reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    FOR             reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    $end            reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    END             reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    ELSE            reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    DO              reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    COMMA           reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    RBRACE          reduce using rule 38 (call_expression -> CALL ID LBRACE arguments RBRACE .)


state 86

    (40) calc_args -> ID COLON STRING . COMMA ID COLON LBRACE arguments RBRACE

    COMMA           shift and go to state 89


state 87

    (12) for_statement -> FOR ID IN expression DO statements . END
    (2) statements -> statements . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) let_statement -> . LET ID ASSIGN expression
    (9) call_statement -> . CALL ID LBRACE arguments RBRACE
    (10) if_statement -> . IF expression THEN statements END
    (11) if_statement -> . IF expression THEN statements ELSE statements END
    (12) for_statement -> . FOR ID IN expression DO statements END

    END             shift and go to state 90
    LET             shift and go to state 8
    CALL            shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11

    statement                      shift and go to state 12
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7

state 88

    (11) if_statement -> IF expression THEN statements ELSE statements END .

    LET             reduce using rule 11 (if_statement -> IF expression THEN statements ELSE statements END .)
    CALL            reduce using rule 11 (if_statement -> IF expression THEN statements ELSE statements END .)
    IF              reduce using rule 11 (if_statement -> IF expression THEN statements ELSE statements END .)
    FOR             reduce using rule 11 (if_statement -> IF expression THEN statements ELSE statements END .)
    $end            reduce using rule 11 (if_statement -> IF expression THEN statements ELSE statements END .)
    END             reduce using rule 11 (if_statement -> IF expression THEN statements ELSE statements END .)
    ELSE            reduce using rule 11 (if_statement -> IF expression THEN statements ELSE statements END .)


state 89

    (40) calc_args -> ID COLON STRING COMMA . ID COLON LBRACE arguments RBRACE

    ID              shift and go to state 91


state 90

    (12) for_statement -> FOR ID IN expression DO statements END .

    LET             reduce using rule 12 (for_statement -> FOR ID IN expression DO statements END .)
    CALL            reduce using rule 12 (for_statement -> FOR ID IN expression DO statements END .)
    IF              reduce using rule 12 (for_statement -> FOR ID IN expression DO statements END .)
    FOR             reduce using rule 12 (for_statement -> FOR ID IN expression DO statements END .)
    $end            reduce using rule 12 (for_statement -> FOR ID IN expression DO statements END .)
    END             reduce using rule 12 (for_statement -> FOR ID IN expression DO statements END .)
    ELSE            reduce using rule 12 (for_statement -> FOR ID IN expression DO statements END .)


state 91

    (40) calc_args -> ID COLON STRING COMMA ID . COLON LBRACE arguments RBRACE

    COLON           shift and go to state 92


state 92

    (40) calc_args -> ID COLON STRING COMMA ID COLON . LBRACE arguments RBRACE

    LBRACE          shift and go to state 93


state 93

    (40) calc_args -> ID COLON STRING COMMA ID COLON LBRACE . arguments RBRACE
    (13) arguments -> . argument_list
    (14) arguments -> . empty
    (15) argument_list -> . argument_list COMMA argument
    (16) argument_list -> . argument
    (18) empty -> .
    (17) argument -> . ID COLON expression

    RBRACE          reduce using rule 18 (empty -> .)
    ID              shift and go to state 52

    arguments                      shift and go to state 94
    argument_list                  shift and go to state 54
    empty                          shift and go to state 55
    argument                       shift and go to state 56

state 94

    (40) calc_args -> ID COLON STRING COMMA ID COLON LBRACE arguments . RBRACE

    RBRACE          shift and go to state 95


state 95

    (40) calc_args -> ID COLON STRING COMMA ID COLON LBRACE arguments RBRACE .

    RBRACE          reduce using rule 40 (calc_args -> ID COLON STRING COMMA ID COLON LBRACE arguments RBRACE .)

