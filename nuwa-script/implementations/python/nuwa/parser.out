Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> script
Rule 1     script -> statements
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> let_statement
Rule 5     statement -> call_statement
Rule 6     statement -> if_statement
Rule 7     statement -> for_statement
Rule 8     statement -> function_call
Rule 9     let_statement -> LET ID ASSIGN expression
Rule 10    call_statement -> CALL ID LBRACE arguments RBRACE
Rule 11    if_statement -> IF expression THEN statements END
Rule 12    if_statement -> IF expression THEN statements ELSE statements END
Rule 13    for_statement -> FOR ID IN expression DO statements END
Rule 14    arguments -> argument_list
Rule 15    arguments -> empty
Rule 16    argument_list -> argument_list COMMA argument
Rule 17    argument_list -> argument
Rule 18    argument -> ID COLON expression
Rule 19    empty -> <empty>
Rule 20    expression -> binary_op
Rule 21    expression -> unary_op
Rule 22    expression -> function_call
Rule 23    expression -> call_expression
Rule 24    expression -> calc_expression
Rule 25    expression -> literal
Rule 26    expression -> variable
Rule 27    expression -> LPAREN expression RPAREN
Rule 28    binary_op -> expression EQ expression
Rule 29    binary_op -> expression NE expression
Rule 30    binary_op -> expression LT expression
Rule 31    binary_op -> expression LE expression
Rule 32    binary_op -> expression GT expression
Rule 33    binary_op -> expression GE expression
Rule 34    binary_op -> expression AND expression
Rule 35    binary_op -> expression OR expression
Rule 36    binary_op -> expression DOT ID
Rule 37    unary_op -> NOT expression
Rule 38    function_call -> NOW LPAREN RPAREN
Rule 39    function_call -> PRINT LPAREN expression RPAREN
Rule 40    call_expression -> CALL ID LBRACE arguments RBRACE
Rule 41    calc_expression -> CALC LBRACE calc_args RBRACE
Rule 42    calc_args -> ID COLON STRING COMMA ID COLON LBRACE arguments RBRACE
Rule 43    literal -> NUMBER
Rule 44    literal -> STRING
Rule 45    literal -> BOOLEAN
Rule 46    variable -> ID

Terminals, with rules where they appear

AND                  : 34
ASSIGN               : 9
BOOLEAN              : 45
CALC                 : 41
CALL                 : 10 40
COLON                : 18 42 42
COMMA                : 16 42
DO                   : 13
DOT                  : 36
ELSE                 : 12
END                  : 11 12 13
EQ                   : 28
FOR                  : 13
GE                   : 33
GT                   : 32
ID                   : 9 10 13 18 36 40 42 42 46
IF                   : 11 12
IN                   : 13
LBRACE               : 10 40 41 42
LE                   : 31
LET                  : 9
LPAREN               : 27 38 39
LT                   : 30
NE                   : 29
NOT                  : 37
NOW                  : 38
NUMBER               : 43
OR                   : 35
PRINT                : 39
RBRACE               : 10 40 41 42
RPAREN               : 27 38 39
STRING               : 42 44
THEN                 : 11 12
error                : 

Nonterminals, with rules where they appear

argument             : 16 17
argument_list        : 14 16
arguments            : 10 40 42
binary_op            : 20
calc_args            : 41
calc_expression      : 24
call_expression      : 23
call_statement       : 5
empty                : 15
expression           : 9 11 12 13 18 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 37 39
for_statement        : 7
function_call        : 8 22
if_statement         : 6
let_statement        : 4
literal              : 25
script               : 0
statement            : 2 3
statements           : 1 2 11 12 12 13
unary_op             : 21
variable             : 26

Parsing method: LALR

state 0

    (0) S' -> . script
    (1) script -> . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) statement -> . function_call
    (9) let_statement -> . LET ID ASSIGN expression
    (10) call_statement -> . CALL ID LBRACE arguments RBRACE
    (11) if_statement -> . IF expression THEN statements END
    (12) if_statement -> . IF expression THEN statements ELSE statements END
    (13) for_statement -> . FOR ID IN expression DO statements END
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN

    LET             shift and go to state 9
    CALL            shift and go to state 10
    IF              shift and go to state 11
    FOR             shift and go to state 12
    NOW             shift and go to state 13
    PRINT           shift and go to state 14

    script                         shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7
    function_call                  shift and go to state 8

state 1

    (0) S' -> script .



state 2

    (1) script -> statements .
    (2) statements -> statements . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) statement -> . function_call
    (9) let_statement -> . LET ID ASSIGN expression
    (10) call_statement -> . CALL ID LBRACE arguments RBRACE
    (11) if_statement -> . IF expression THEN statements END
    (12) if_statement -> . IF expression THEN statements ELSE statements END
    (13) for_statement -> . FOR ID IN expression DO statements END
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN

    $end            reduce using rule 1 (script -> statements .)
    LET             shift and go to state 9
    CALL            shift and go to state 10
    IF              shift and go to state 11
    FOR             shift and go to state 12
    NOW             shift and go to state 13
    PRINT           shift and go to state 14

    statement                      shift and go to state 15
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7
    function_call                  shift and go to state 8

state 3

    (3) statements -> statement .

    LET             reduce using rule 3 (statements -> statement .)
    CALL            reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    NOW             reduce using rule 3 (statements -> statement .)
    PRINT           reduce using rule 3 (statements -> statement .)
    $end            reduce using rule 3 (statements -> statement .)
    END             reduce using rule 3 (statements -> statement .)
    ELSE            reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> let_statement .

    LET             reduce using rule 4 (statement -> let_statement .)
    CALL            reduce using rule 4 (statement -> let_statement .)
    IF              reduce using rule 4 (statement -> let_statement .)
    FOR             reduce using rule 4 (statement -> let_statement .)
    NOW             reduce using rule 4 (statement -> let_statement .)
    PRINT           reduce using rule 4 (statement -> let_statement .)
    $end            reduce using rule 4 (statement -> let_statement .)
    END             reduce using rule 4 (statement -> let_statement .)
    ELSE            reduce using rule 4 (statement -> let_statement .)


state 5

    (5) statement -> call_statement .

    LET             reduce using rule 5 (statement -> call_statement .)
    CALL            reduce using rule 5 (statement -> call_statement .)
    IF              reduce using rule 5 (statement -> call_statement .)
    FOR             reduce using rule 5 (statement -> call_statement .)
    NOW             reduce using rule 5 (statement -> call_statement .)
    PRINT           reduce using rule 5 (statement -> call_statement .)
    $end            reduce using rule 5 (statement -> call_statement .)
    END             reduce using rule 5 (statement -> call_statement .)
    ELSE            reduce using rule 5 (statement -> call_statement .)


state 6

    (6) statement -> if_statement .

    LET             reduce using rule 6 (statement -> if_statement .)
    CALL            reduce using rule 6 (statement -> if_statement .)
    IF              reduce using rule 6 (statement -> if_statement .)
    FOR             reduce using rule 6 (statement -> if_statement .)
    NOW             reduce using rule 6 (statement -> if_statement .)
    PRINT           reduce using rule 6 (statement -> if_statement .)
    $end            reduce using rule 6 (statement -> if_statement .)
    END             reduce using rule 6 (statement -> if_statement .)
    ELSE            reduce using rule 6 (statement -> if_statement .)


state 7

    (7) statement -> for_statement .

    LET             reduce using rule 7 (statement -> for_statement .)
    CALL            reduce using rule 7 (statement -> for_statement .)
    IF              reduce using rule 7 (statement -> for_statement .)
    FOR             reduce using rule 7 (statement -> for_statement .)
    NOW             reduce using rule 7 (statement -> for_statement .)
    PRINT           reduce using rule 7 (statement -> for_statement .)
    $end            reduce using rule 7 (statement -> for_statement .)
    END             reduce using rule 7 (statement -> for_statement .)
    ELSE            reduce using rule 7 (statement -> for_statement .)


state 8

    (8) statement -> function_call .

    LET             reduce using rule 8 (statement -> function_call .)
    CALL            reduce using rule 8 (statement -> function_call .)
    IF              reduce using rule 8 (statement -> function_call .)
    FOR             reduce using rule 8 (statement -> function_call .)
    NOW             reduce using rule 8 (statement -> function_call .)
    PRINT           reduce using rule 8 (statement -> function_call .)
    $end            reduce using rule 8 (statement -> function_call .)
    END             reduce using rule 8 (statement -> function_call .)
    ELSE            reduce using rule 8 (statement -> function_call .)


state 9

    (9) let_statement -> LET . ID ASSIGN expression

    ID              shift and go to state 16


state 10

    (10) call_statement -> CALL . ID LBRACE arguments RBRACE

    ID              shift and go to state 17


state 11

    (11) if_statement -> IF . expression THEN statements END
    (12) if_statement -> IF . expression THEN statements ELSE statements END
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 18
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 12

    (13) for_statement -> FOR . ID IN expression DO statements END

    ID              shift and go to state 34


state 13

    (38) function_call -> NOW . LPAREN RPAREN

    LPAREN          shift and go to state 35


state 14

    (39) function_call -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 36


state 15

    (2) statements -> statements statement .

    LET             reduce using rule 2 (statements -> statements statement .)
    CALL            reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    FOR             reduce using rule 2 (statements -> statements statement .)
    NOW             reduce using rule 2 (statements -> statements statement .)
    PRINT           reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)
    END             reduce using rule 2 (statements -> statements statement .)
    ELSE            reduce using rule 2 (statements -> statements statement .)


state 16

    (9) let_statement -> LET ID . ASSIGN expression

    ASSIGN          shift and go to state 37


state 17

    (10) call_statement -> CALL ID . LBRACE arguments RBRACE

    LBRACE          shift and go to state 38


state 18

    (11) if_statement -> IF expression . THEN statements END
    (12) if_statement -> IF expression . THEN statements ELSE statements END
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            shift and go to state 39
    EQ              shift and go to state 40
    NE              shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    DOT             shift and go to state 48


state 19

    (20) expression -> binary_op .

    THEN            reduce using rule 20 (expression -> binary_op .)
    EQ              reduce using rule 20 (expression -> binary_op .)
    NE              reduce using rule 20 (expression -> binary_op .)
    LT              reduce using rule 20 (expression -> binary_op .)
    LE              reduce using rule 20 (expression -> binary_op .)
    GT              reduce using rule 20 (expression -> binary_op .)
    GE              reduce using rule 20 (expression -> binary_op .)
    AND             reduce using rule 20 (expression -> binary_op .)
    OR              reduce using rule 20 (expression -> binary_op .)
    DOT             reduce using rule 20 (expression -> binary_op .)
    RPAREN          reduce using rule 20 (expression -> binary_op .)
    LET             reduce using rule 20 (expression -> binary_op .)
    CALL            reduce using rule 20 (expression -> binary_op .)
    IF              reduce using rule 20 (expression -> binary_op .)
    FOR             reduce using rule 20 (expression -> binary_op .)
    NOW             reduce using rule 20 (expression -> binary_op .)
    PRINT           reduce using rule 20 (expression -> binary_op .)
    $end            reduce using rule 20 (expression -> binary_op .)
    END             reduce using rule 20 (expression -> binary_op .)
    ELSE            reduce using rule 20 (expression -> binary_op .)
    DO              reduce using rule 20 (expression -> binary_op .)
    COMMA           reduce using rule 20 (expression -> binary_op .)
    RBRACE          reduce using rule 20 (expression -> binary_op .)


state 20

    (21) expression -> unary_op .

    THEN            reduce using rule 21 (expression -> unary_op .)
    EQ              reduce using rule 21 (expression -> unary_op .)
    NE              reduce using rule 21 (expression -> unary_op .)
    LT              reduce using rule 21 (expression -> unary_op .)
    LE              reduce using rule 21 (expression -> unary_op .)
    GT              reduce using rule 21 (expression -> unary_op .)
    GE              reduce using rule 21 (expression -> unary_op .)
    AND             reduce using rule 21 (expression -> unary_op .)
    OR              reduce using rule 21 (expression -> unary_op .)
    DOT             reduce using rule 21 (expression -> unary_op .)
    RPAREN          reduce using rule 21 (expression -> unary_op .)
    LET             reduce using rule 21 (expression -> unary_op .)
    CALL            reduce using rule 21 (expression -> unary_op .)
    IF              reduce using rule 21 (expression -> unary_op .)
    FOR             reduce using rule 21 (expression -> unary_op .)
    NOW             reduce using rule 21 (expression -> unary_op .)
    PRINT           reduce using rule 21 (expression -> unary_op .)
    $end            reduce using rule 21 (expression -> unary_op .)
    END             reduce using rule 21 (expression -> unary_op .)
    ELSE            reduce using rule 21 (expression -> unary_op .)
    DO              reduce using rule 21 (expression -> unary_op .)
    COMMA           reduce using rule 21 (expression -> unary_op .)
    RBRACE          reduce using rule 21 (expression -> unary_op .)


state 21

    (22) expression -> function_call .

    THEN            reduce using rule 22 (expression -> function_call .)
    EQ              reduce using rule 22 (expression -> function_call .)
    NE              reduce using rule 22 (expression -> function_call .)
    LT              reduce using rule 22 (expression -> function_call .)
    LE              reduce using rule 22 (expression -> function_call .)
    GT              reduce using rule 22 (expression -> function_call .)
    GE              reduce using rule 22 (expression -> function_call .)
    AND             reduce using rule 22 (expression -> function_call .)
    OR              reduce using rule 22 (expression -> function_call .)
    DOT             reduce using rule 22 (expression -> function_call .)
    RPAREN          reduce using rule 22 (expression -> function_call .)
    LET             reduce using rule 22 (expression -> function_call .)
    CALL            reduce using rule 22 (expression -> function_call .)
    IF              reduce using rule 22 (expression -> function_call .)
    FOR             reduce using rule 22 (expression -> function_call .)
    NOW             reduce using rule 22 (expression -> function_call .)
    PRINT           reduce using rule 22 (expression -> function_call .)
    $end            reduce using rule 22 (expression -> function_call .)
    END             reduce using rule 22 (expression -> function_call .)
    ELSE            reduce using rule 22 (expression -> function_call .)
    DO              reduce using rule 22 (expression -> function_call .)
    COMMA           reduce using rule 22 (expression -> function_call .)
    RBRACE          reduce using rule 22 (expression -> function_call .)


state 22

    (23) expression -> call_expression .

    THEN            reduce using rule 23 (expression -> call_expression .)
    EQ              reduce using rule 23 (expression -> call_expression .)
    NE              reduce using rule 23 (expression -> call_expression .)
    LT              reduce using rule 23 (expression -> call_expression .)
    LE              reduce using rule 23 (expression -> call_expression .)
    GT              reduce using rule 23 (expression -> call_expression .)
    GE              reduce using rule 23 (expression -> call_expression .)
    AND             reduce using rule 23 (expression -> call_expression .)
    OR              reduce using rule 23 (expression -> call_expression .)
    DOT             reduce using rule 23 (expression -> call_expression .)
    RPAREN          reduce using rule 23 (expression -> call_expression .)
    LET             reduce using rule 23 (expression -> call_expression .)
    CALL            reduce using rule 23 (expression -> call_expression .)
    IF              reduce using rule 23 (expression -> call_expression .)
    FOR             reduce using rule 23 (expression -> call_expression .)
    NOW             reduce using rule 23 (expression -> call_expression .)
    PRINT           reduce using rule 23 (expression -> call_expression .)
    $end            reduce using rule 23 (expression -> call_expression .)
    END             reduce using rule 23 (expression -> call_expression .)
    ELSE            reduce using rule 23 (expression -> call_expression .)
    DO              reduce using rule 23 (expression -> call_expression .)
    COMMA           reduce using rule 23 (expression -> call_expression .)
    RBRACE          reduce using rule 23 (expression -> call_expression .)


state 23

    (24) expression -> calc_expression .

    THEN            reduce using rule 24 (expression -> calc_expression .)
    EQ              reduce using rule 24 (expression -> calc_expression .)
    NE              reduce using rule 24 (expression -> calc_expression .)
    LT              reduce using rule 24 (expression -> calc_expression .)
    LE              reduce using rule 24 (expression -> calc_expression .)
    GT              reduce using rule 24 (expression -> calc_expression .)
    GE              reduce using rule 24 (expression -> calc_expression .)
    AND             reduce using rule 24 (expression -> calc_expression .)
    OR              reduce using rule 24 (expression -> calc_expression .)
    DOT             reduce using rule 24 (expression -> calc_expression .)
    RPAREN          reduce using rule 24 (expression -> calc_expression .)
    LET             reduce using rule 24 (expression -> calc_expression .)
    CALL            reduce using rule 24 (expression -> calc_expression .)
    IF              reduce using rule 24 (expression -> calc_expression .)
    FOR             reduce using rule 24 (expression -> calc_expression .)
    NOW             reduce using rule 24 (expression -> calc_expression .)
    PRINT           reduce using rule 24 (expression -> calc_expression .)
    $end            reduce using rule 24 (expression -> calc_expression .)
    END             reduce using rule 24 (expression -> calc_expression .)
    ELSE            reduce using rule 24 (expression -> calc_expression .)
    DO              reduce using rule 24 (expression -> calc_expression .)
    COMMA           reduce using rule 24 (expression -> calc_expression .)
    RBRACE          reduce using rule 24 (expression -> calc_expression .)


state 24

    (25) expression -> literal .

    THEN            reduce using rule 25 (expression -> literal .)
    EQ              reduce using rule 25 (expression -> literal .)
    NE              reduce using rule 25 (expression -> literal .)
    LT              reduce using rule 25 (expression -> literal .)
    LE              reduce using rule 25 (expression -> literal .)
    GT              reduce using rule 25 (expression -> literal .)
    GE              reduce using rule 25 (expression -> literal .)
    AND             reduce using rule 25 (expression -> literal .)
    OR              reduce using rule 25 (expression -> literal .)
    DOT             reduce using rule 25 (expression -> literal .)
    RPAREN          reduce using rule 25 (expression -> literal .)
    LET             reduce using rule 25 (expression -> literal .)
    CALL            reduce using rule 25 (expression -> literal .)
    IF              reduce using rule 25 (expression -> literal .)
    FOR             reduce using rule 25 (expression -> literal .)
    NOW             reduce using rule 25 (expression -> literal .)
    PRINT           reduce using rule 25 (expression -> literal .)
    $end            reduce using rule 25 (expression -> literal .)
    END             reduce using rule 25 (expression -> literal .)
    ELSE            reduce using rule 25 (expression -> literal .)
    DO              reduce using rule 25 (expression -> literal .)
    COMMA           reduce using rule 25 (expression -> literal .)
    RBRACE          reduce using rule 25 (expression -> literal .)


state 25

    (26) expression -> variable .

    THEN            reduce using rule 26 (expression -> variable .)
    EQ              reduce using rule 26 (expression -> variable .)
    NE              reduce using rule 26 (expression -> variable .)
    LT              reduce using rule 26 (expression -> variable .)
    LE              reduce using rule 26 (expression -> variable .)
    GT              reduce using rule 26 (expression -> variable .)
    GE              reduce using rule 26 (expression -> variable .)
    AND             reduce using rule 26 (expression -> variable .)
    OR              reduce using rule 26 (expression -> variable .)
    DOT             reduce using rule 26 (expression -> variable .)
    RPAREN          reduce using rule 26 (expression -> variable .)
    LET             reduce using rule 26 (expression -> variable .)
    CALL            reduce using rule 26 (expression -> variable .)
    IF              reduce using rule 26 (expression -> variable .)
    FOR             reduce using rule 26 (expression -> variable .)
    NOW             reduce using rule 26 (expression -> variable .)
    PRINT           reduce using rule 26 (expression -> variable .)
    $end            reduce using rule 26 (expression -> variable .)
    END             reduce using rule 26 (expression -> variable .)
    ELSE            reduce using rule 26 (expression -> variable .)
    DO              reduce using rule 26 (expression -> variable .)
    COMMA           reduce using rule 26 (expression -> variable .)
    RBRACE          reduce using rule 26 (expression -> variable .)


state 26

    (27) expression -> LPAREN . expression RPAREN
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 49
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 27

    (46) variable -> ID .

    THEN            reduce using rule 46 (variable -> ID .)
    EQ              reduce using rule 46 (variable -> ID .)
    NE              reduce using rule 46 (variable -> ID .)
    LT              reduce using rule 46 (variable -> ID .)
    LE              reduce using rule 46 (variable -> ID .)
    GT              reduce using rule 46 (variable -> ID .)
    GE              reduce using rule 46 (variable -> ID .)
    AND             reduce using rule 46 (variable -> ID .)
    OR              reduce using rule 46 (variable -> ID .)
    DOT             reduce using rule 46 (variable -> ID .)
    RPAREN          reduce using rule 46 (variable -> ID .)
    LET             reduce using rule 46 (variable -> ID .)
    CALL            reduce using rule 46 (variable -> ID .)
    IF              reduce using rule 46 (variable -> ID .)
    FOR             reduce using rule 46 (variable -> ID .)
    NOW             reduce using rule 46 (variable -> ID .)
    PRINT           reduce using rule 46 (variable -> ID .)
    $end            reduce using rule 46 (variable -> ID .)
    END             reduce using rule 46 (variable -> ID .)
    ELSE            reduce using rule 46 (variable -> ID .)
    DO              reduce using rule 46 (variable -> ID .)
    COMMA           reduce using rule 46 (variable -> ID .)
    RBRACE          reduce using rule 46 (variable -> ID .)


state 28

    (37) unary_op -> NOT . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 50
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 29

    (40) call_expression -> CALL . ID LBRACE arguments RBRACE

    ID              shift and go to state 51


state 30

    (41) calc_expression -> CALC . LBRACE calc_args RBRACE

    LBRACE          shift and go to state 52


state 31

    (43) literal -> NUMBER .

    THEN            reduce using rule 43 (literal -> NUMBER .)
    EQ              reduce using rule 43 (literal -> NUMBER .)
    NE              reduce using rule 43 (literal -> NUMBER .)
    LT              reduce using rule 43 (literal -> NUMBER .)
    LE              reduce using rule 43 (literal -> NUMBER .)
    GT              reduce using rule 43 (literal -> NUMBER .)
    GE              reduce using rule 43 (literal -> NUMBER .)
    AND             reduce using rule 43 (literal -> NUMBER .)
    OR              reduce using rule 43 (literal -> NUMBER .)
    DOT             reduce using rule 43 (literal -> NUMBER .)
    RPAREN          reduce using rule 43 (literal -> NUMBER .)
    LET             reduce using rule 43 (literal -> NUMBER .)
    CALL            reduce using rule 43 (literal -> NUMBER .)
    IF              reduce using rule 43 (literal -> NUMBER .)
    FOR             reduce using rule 43 (literal -> NUMBER .)
    NOW             reduce using rule 43 (literal -> NUMBER .)
    PRINT           reduce using rule 43 (literal -> NUMBER .)
    $end            reduce using rule 43 (literal -> NUMBER .)
    END             reduce using rule 43 (literal -> NUMBER .)
    ELSE            reduce using rule 43 (literal -> NUMBER .)
    DO              reduce using rule 43 (literal -> NUMBER .)
    COMMA           reduce using rule 43 (literal -> NUMBER .)
    RBRACE          reduce using rule 43 (literal -> NUMBER .)


state 32

    (44) literal -> STRING .

    THEN            reduce using rule 44 (literal -> STRING .)
    EQ              reduce using rule 44 (literal -> STRING .)
    NE              reduce using rule 44 (literal -> STRING .)
    LT              reduce using rule 44 (literal -> STRING .)
    LE              reduce using rule 44 (literal -> STRING .)
    GT              reduce using rule 44 (literal -> STRING .)
    GE              reduce using rule 44 (literal -> STRING .)
    AND             reduce using rule 44 (literal -> STRING .)
    OR              reduce using rule 44 (literal -> STRING .)
    DOT             reduce using rule 44 (literal -> STRING .)
    RPAREN          reduce using rule 44 (literal -> STRING .)
    LET             reduce using rule 44 (literal -> STRING .)
    CALL            reduce using rule 44 (literal -> STRING .)
    IF              reduce using rule 44 (literal -> STRING .)
    FOR             reduce using rule 44 (literal -> STRING .)
    NOW             reduce using rule 44 (literal -> STRING .)
    PRINT           reduce using rule 44 (literal -> STRING .)
    $end            reduce using rule 44 (literal -> STRING .)
    END             reduce using rule 44 (literal -> STRING .)
    ELSE            reduce using rule 44 (literal -> STRING .)
    DO              reduce using rule 44 (literal -> STRING .)
    COMMA           reduce using rule 44 (literal -> STRING .)
    RBRACE          reduce using rule 44 (literal -> STRING .)


state 33

    (45) literal -> BOOLEAN .

    THEN            reduce using rule 45 (literal -> BOOLEAN .)
    EQ              reduce using rule 45 (literal -> BOOLEAN .)
    NE              reduce using rule 45 (literal -> BOOLEAN .)
    LT              reduce using rule 45 (literal -> BOOLEAN .)
    LE              reduce using rule 45 (literal -> BOOLEAN .)
    GT              reduce using rule 45 (literal -> BOOLEAN .)
    GE              reduce using rule 45 (literal -> BOOLEAN .)
    AND             reduce using rule 45 (literal -> BOOLEAN .)
    OR              reduce using rule 45 (literal -> BOOLEAN .)
    DOT             reduce using rule 45 (literal -> BOOLEAN .)
    RPAREN          reduce using rule 45 (literal -> BOOLEAN .)
    LET             reduce using rule 45 (literal -> BOOLEAN .)
    CALL            reduce using rule 45 (literal -> BOOLEAN .)
    IF              reduce using rule 45 (literal -> BOOLEAN .)
    FOR             reduce using rule 45 (literal -> BOOLEAN .)
    NOW             reduce using rule 45 (literal -> BOOLEAN .)
    PRINT           reduce using rule 45 (literal -> BOOLEAN .)
    $end            reduce using rule 45 (literal -> BOOLEAN .)
    END             reduce using rule 45 (literal -> BOOLEAN .)
    ELSE            reduce using rule 45 (literal -> BOOLEAN .)
    DO              reduce using rule 45 (literal -> BOOLEAN .)
    COMMA           reduce using rule 45 (literal -> BOOLEAN .)
    RBRACE          reduce using rule 45 (literal -> BOOLEAN .)


state 34

    (13) for_statement -> FOR ID . IN expression DO statements END

    IN              shift and go to state 53


state 35

    (38) function_call -> NOW LPAREN . RPAREN

    RPAREN          shift and go to state 54


state 36

    (39) function_call -> PRINT LPAREN . expression RPAREN
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 55
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 37

    (9) let_statement -> LET ID ASSIGN . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 56
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 38

    (10) call_statement -> CALL ID LBRACE . arguments RBRACE
    (14) arguments -> . argument_list
    (15) arguments -> . empty
    (16) argument_list -> . argument_list COMMA argument
    (17) argument_list -> . argument
    (19) empty -> .
    (18) argument -> . ID COLON expression

    RBRACE          reduce using rule 19 (empty -> .)
    ID              shift and go to state 57

    arguments                      shift and go to state 58
    argument_list                  shift and go to state 59
    empty                          shift and go to state 60
    argument                       shift and go to state 61

state 39

    (11) if_statement -> IF expression THEN . statements END
    (12) if_statement -> IF expression THEN . statements ELSE statements END
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) statement -> . function_call
    (9) let_statement -> . LET ID ASSIGN expression
    (10) call_statement -> . CALL ID LBRACE arguments RBRACE
    (11) if_statement -> . IF expression THEN statements END
    (12) if_statement -> . IF expression THEN statements ELSE statements END
    (13) for_statement -> . FOR ID IN expression DO statements END
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN

    LET             shift and go to state 9
    CALL            shift and go to state 10
    IF              shift and go to state 11
    FOR             shift and go to state 12
    NOW             shift and go to state 13
    PRINT           shift and go to state 14

    statements                     shift and go to state 62
    statement                      shift and go to state 3
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7
    function_call                  shift and go to state 8

state 40

    (28) binary_op -> expression EQ . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 63
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 41

    (29) binary_op -> expression NE . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 64
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 42

    (30) binary_op -> expression LT . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 65
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 43

    (31) binary_op -> expression LE . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 66
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 44

    (32) binary_op -> expression GT . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 67
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 45

    (33) binary_op -> expression GE . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 68
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 46

    (34) binary_op -> expression AND . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 69
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 47

    (35) binary_op -> expression OR . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 70
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 48

    (36) binary_op -> expression DOT . ID

    ID              shift and go to state 71


state 49

    (27) expression -> LPAREN expression . RPAREN
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    RPAREN          shift and go to state 72
    EQ              shift and go to state 40
    NE              shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    DOT             shift and go to state 48


state 50

    (37) unary_op -> NOT expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            reduce using rule 37 (unary_op -> NOT expression .)
    AND             reduce using rule 37 (unary_op -> NOT expression .)
    OR              reduce using rule 37 (unary_op -> NOT expression .)
    DOT             reduce using rule 37 (unary_op -> NOT expression .)
    RPAREN          reduce using rule 37 (unary_op -> NOT expression .)
    LET             reduce using rule 37 (unary_op -> NOT expression .)
    CALL            reduce using rule 37 (unary_op -> NOT expression .)
    IF              reduce using rule 37 (unary_op -> NOT expression .)
    FOR             reduce using rule 37 (unary_op -> NOT expression .)
    NOW             reduce using rule 37 (unary_op -> NOT expression .)
    PRINT           reduce using rule 37 (unary_op -> NOT expression .)
    $end            reduce using rule 37 (unary_op -> NOT expression .)
    END             reduce using rule 37 (unary_op -> NOT expression .)
    ELSE            reduce using rule 37 (unary_op -> NOT expression .)
    DO              reduce using rule 37 (unary_op -> NOT expression .)
    COMMA           reduce using rule 37 (unary_op -> NOT expression .)
    RBRACE          reduce using rule 37 (unary_op -> NOT expression .)
    EQ              shift and go to state 40
    NE              shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45

  ! EQ              [ reduce using rule 37 (unary_op -> NOT expression .) ]
  ! NE              [ reduce using rule 37 (unary_op -> NOT expression .) ]
  ! LT              [ reduce using rule 37 (unary_op -> NOT expression .) ]
  ! LE              [ reduce using rule 37 (unary_op -> NOT expression .) ]
  ! GT              [ reduce using rule 37 (unary_op -> NOT expression .) ]
  ! GE              [ reduce using rule 37 (unary_op -> NOT expression .) ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! DOT             [ shift and go to state 48 ]


state 51

    (40) call_expression -> CALL ID . LBRACE arguments RBRACE

    LBRACE          shift and go to state 73


state 52

    (41) calc_expression -> CALC LBRACE . calc_args RBRACE
    (42) calc_args -> . ID COLON STRING COMMA ID COLON LBRACE arguments RBRACE

    ID              shift and go to state 75

    calc_args                      shift and go to state 74

state 53

    (13) for_statement -> FOR ID IN . expression DO statements END
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 76
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 54

    (38) function_call -> NOW LPAREN RPAREN .

    LET             reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    CALL            reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    IF              reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    FOR             reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    NOW             reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    PRINT           reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    $end            reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    THEN            reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    EQ              reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    NE              reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    LT              reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    LE              reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    GT              reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    GE              reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    AND             reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    OR              reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    DOT             reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    RPAREN          reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    END             reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    ELSE            reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    DO              reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    COMMA           reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)
    RBRACE          reduce using rule 38 (function_call -> NOW LPAREN RPAREN .)


state 55

    (39) function_call -> PRINT LPAREN expression . RPAREN
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    RPAREN          shift and go to state 77
    EQ              shift and go to state 40
    NE              shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    DOT             shift and go to state 48


state 56

    (9) let_statement -> LET ID ASSIGN expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    LET             reduce using rule 9 (let_statement -> LET ID ASSIGN expression .)
    CALL            reduce using rule 9 (let_statement -> LET ID ASSIGN expression .)
    IF              reduce using rule 9 (let_statement -> LET ID ASSIGN expression .)
    FOR             reduce using rule 9 (let_statement -> LET ID ASSIGN expression .)
    NOW             reduce using rule 9 (let_statement -> LET ID ASSIGN expression .)
    PRINT           reduce using rule 9 (let_statement -> LET ID ASSIGN expression .)
    $end            reduce using rule 9 (let_statement -> LET ID ASSIGN expression .)
    END             reduce using rule 9 (let_statement -> LET ID ASSIGN expression .)
    ELSE            reduce using rule 9 (let_statement -> LET ID ASSIGN expression .)
    EQ              shift and go to state 40
    NE              shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    DOT             shift and go to state 48


state 57

    (18) argument -> ID . COLON expression

    COLON           shift and go to state 78


state 58

    (10) call_statement -> CALL ID LBRACE arguments . RBRACE

    RBRACE          shift and go to state 79


state 59

    (14) arguments -> argument_list .
    (16) argument_list -> argument_list . COMMA argument

    RBRACE          reduce using rule 14 (arguments -> argument_list .)
    COMMA           shift and go to state 80


state 60

    (15) arguments -> empty .

    RBRACE          reduce using rule 15 (arguments -> empty .)


state 61

    (17) argument_list -> argument .

    COMMA           reduce using rule 17 (argument_list -> argument .)
    RBRACE          reduce using rule 17 (argument_list -> argument .)


state 62

    (11) if_statement -> IF expression THEN statements . END
    (12) if_statement -> IF expression THEN statements . ELSE statements END
    (2) statements -> statements . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) statement -> . function_call
    (9) let_statement -> . LET ID ASSIGN expression
    (10) call_statement -> . CALL ID LBRACE arguments RBRACE
    (11) if_statement -> . IF expression THEN statements END
    (12) if_statement -> . IF expression THEN statements ELSE statements END
    (13) for_statement -> . FOR ID IN expression DO statements END
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN

    END             shift and go to state 81
    ELSE            shift and go to state 82
    LET             shift and go to state 9
    CALL            shift and go to state 10
    IF              shift and go to state 11
    FOR             shift and go to state 12
    NOW             shift and go to state 13
    PRINT           shift and go to state 14

    statement                      shift and go to state 15
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7
    function_call                  shift and go to state 8

state 63

    (28) binary_op -> expression EQ expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            reduce using rule 28 (binary_op -> expression EQ expression .)
    EQ              reduce using rule 28 (binary_op -> expression EQ expression .)
    NE              reduce using rule 28 (binary_op -> expression EQ expression .)
    LT              reduce using rule 28 (binary_op -> expression EQ expression .)
    LE              reduce using rule 28 (binary_op -> expression EQ expression .)
    GT              reduce using rule 28 (binary_op -> expression EQ expression .)
    GE              reduce using rule 28 (binary_op -> expression EQ expression .)
    AND             reduce using rule 28 (binary_op -> expression EQ expression .)
    OR              reduce using rule 28 (binary_op -> expression EQ expression .)
    DOT             reduce using rule 28 (binary_op -> expression EQ expression .)
    RPAREN          reduce using rule 28 (binary_op -> expression EQ expression .)
    LET             reduce using rule 28 (binary_op -> expression EQ expression .)
    CALL            reduce using rule 28 (binary_op -> expression EQ expression .)
    IF              reduce using rule 28 (binary_op -> expression EQ expression .)
    FOR             reduce using rule 28 (binary_op -> expression EQ expression .)
    NOW             reduce using rule 28 (binary_op -> expression EQ expression .)
    PRINT           reduce using rule 28 (binary_op -> expression EQ expression .)
    $end            reduce using rule 28 (binary_op -> expression EQ expression .)
    END             reduce using rule 28 (binary_op -> expression EQ expression .)
    ELSE            reduce using rule 28 (binary_op -> expression EQ expression .)
    DO              reduce using rule 28 (binary_op -> expression EQ expression .)
    COMMA           reduce using rule 28 (binary_op -> expression EQ expression .)
    RBRACE          reduce using rule 28 (binary_op -> expression EQ expression .)

  ! EQ              [ shift and go to state 40 ]
  ! NE              [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! DOT             [ shift and go to state 48 ]


state 64

    (29) binary_op -> expression NE expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            reduce using rule 29 (binary_op -> expression NE expression .)
    EQ              reduce using rule 29 (binary_op -> expression NE expression .)
    NE              reduce using rule 29 (binary_op -> expression NE expression .)
    LT              reduce using rule 29 (binary_op -> expression NE expression .)
    LE              reduce using rule 29 (binary_op -> expression NE expression .)
    GT              reduce using rule 29 (binary_op -> expression NE expression .)
    GE              reduce using rule 29 (binary_op -> expression NE expression .)
    AND             reduce using rule 29 (binary_op -> expression NE expression .)
    OR              reduce using rule 29 (binary_op -> expression NE expression .)
    DOT             reduce using rule 29 (binary_op -> expression NE expression .)
    RPAREN          reduce using rule 29 (binary_op -> expression NE expression .)
    LET             reduce using rule 29 (binary_op -> expression NE expression .)
    CALL            reduce using rule 29 (binary_op -> expression NE expression .)
    IF              reduce using rule 29 (binary_op -> expression NE expression .)
    FOR             reduce using rule 29 (binary_op -> expression NE expression .)
    NOW             reduce using rule 29 (binary_op -> expression NE expression .)
    PRINT           reduce using rule 29 (binary_op -> expression NE expression .)
    $end            reduce using rule 29 (binary_op -> expression NE expression .)
    END             reduce using rule 29 (binary_op -> expression NE expression .)
    ELSE            reduce using rule 29 (binary_op -> expression NE expression .)
    DO              reduce using rule 29 (binary_op -> expression NE expression .)
    COMMA           reduce using rule 29 (binary_op -> expression NE expression .)
    RBRACE          reduce using rule 29 (binary_op -> expression NE expression .)

  ! EQ              [ shift and go to state 40 ]
  ! NE              [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! DOT             [ shift and go to state 48 ]


state 65

    (30) binary_op -> expression LT expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            reduce using rule 30 (binary_op -> expression LT expression .)
    EQ              reduce using rule 30 (binary_op -> expression LT expression .)
    NE              reduce using rule 30 (binary_op -> expression LT expression .)
    LT              reduce using rule 30 (binary_op -> expression LT expression .)
    LE              reduce using rule 30 (binary_op -> expression LT expression .)
    GT              reduce using rule 30 (binary_op -> expression LT expression .)
    GE              reduce using rule 30 (binary_op -> expression LT expression .)
    AND             reduce using rule 30 (binary_op -> expression LT expression .)
    OR              reduce using rule 30 (binary_op -> expression LT expression .)
    DOT             reduce using rule 30 (binary_op -> expression LT expression .)
    RPAREN          reduce using rule 30 (binary_op -> expression LT expression .)
    LET             reduce using rule 30 (binary_op -> expression LT expression .)
    CALL            reduce using rule 30 (binary_op -> expression LT expression .)
    IF              reduce using rule 30 (binary_op -> expression LT expression .)
    FOR             reduce using rule 30 (binary_op -> expression LT expression .)
    NOW             reduce using rule 30 (binary_op -> expression LT expression .)
    PRINT           reduce using rule 30 (binary_op -> expression LT expression .)
    $end            reduce using rule 30 (binary_op -> expression LT expression .)
    END             reduce using rule 30 (binary_op -> expression LT expression .)
    ELSE            reduce using rule 30 (binary_op -> expression LT expression .)
    DO              reduce using rule 30 (binary_op -> expression LT expression .)
    COMMA           reduce using rule 30 (binary_op -> expression LT expression .)
    RBRACE          reduce using rule 30 (binary_op -> expression LT expression .)

  ! EQ              [ shift and go to state 40 ]
  ! NE              [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! DOT             [ shift and go to state 48 ]


state 66

    (31) binary_op -> expression LE expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            reduce using rule 31 (binary_op -> expression LE expression .)
    EQ              reduce using rule 31 (binary_op -> expression LE expression .)
    NE              reduce using rule 31 (binary_op -> expression LE expression .)
    LT              reduce using rule 31 (binary_op -> expression LE expression .)
    LE              reduce using rule 31 (binary_op -> expression LE expression .)
    GT              reduce using rule 31 (binary_op -> expression LE expression .)
    GE              reduce using rule 31 (binary_op -> expression LE expression .)
    AND             reduce using rule 31 (binary_op -> expression LE expression .)
    OR              reduce using rule 31 (binary_op -> expression LE expression .)
    DOT             reduce using rule 31 (binary_op -> expression LE expression .)
    RPAREN          reduce using rule 31 (binary_op -> expression LE expression .)
    LET             reduce using rule 31 (binary_op -> expression LE expression .)
    CALL            reduce using rule 31 (binary_op -> expression LE expression .)
    IF              reduce using rule 31 (binary_op -> expression LE expression .)
    FOR             reduce using rule 31 (binary_op -> expression LE expression .)
    NOW             reduce using rule 31 (binary_op -> expression LE expression .)
    PRINT           reduce using rule 31 (binary_op -> expression LE expression .)
    $end            reduce using rule 31 (binary_op -> expression LE expression .)
    END             reduce using rule 31 (binary_op -> expression LE expression .)
    ELSE            reduce using rule 31 (binary_op -> expression LE expression .)
    DO              reduce using rule 31 (binary_op -> expression LE expression .)
    COMMA           reduce using rule 31 (binary_op -> expression LE expression .)
    RBRACE          reduce using rule 31 (binary_op -> expression LE expression .)

  ! EQ              [ shift and go to state 40 ]
  ! NE              [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! DOT             [ shift and go to state 48 ]


state 67

    (32) binary_op -> expression GT expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            reduce using rule 32 (binary_op -> expression GT expression .)
    EQ              reduce using rule 32 (binary_op -> expression GT expression .)
    NE              reduce using rule 32 (binary_op -> expression GT expression .)
    LT              reduce using rule 32 (binary_op -> expression GT expression .)
    LE              reduce using rule 32 (binary_op -> expression GT expression .)
    GT              reduce using rule 32 (binary_op -> expression GT expression .)
    GE              reduce using rule 32 (binary_op -> expression GT expression .)
    AND             reduce using rule 32 (binary_op -> expression GT expression .)
    OR              reduce using rule 32 (binary_op -> expression GT expression .)
    DOT             reduce using rule 32 (binary_op -> expression GT expression .)
    RPAREN          reduce using rule 32 (binary_op -> expression GT expression .)
    LET             reduce using rule 32 (binary_op -> expression GT expression .)
    CALL            reduce using rule 32 (binary_op -> expression GT expression .)
    IF              reduce using rule 32 (binary_op -> expression GT expression .)
    FOR             reduce using rule 32 (binary_op -> expression GT expression .)
    NOW             reduce using rule 32 (binary_op -> expression GT expression .)
    PRINT           reduce using rule 32 (binary_op -> expression GT expression .)
    $end            reduce using rule 32 (binary_op -> expression GT expression .)
    END             reduce using rule 32 (binary_op -> expression GT expression .)
    ELSE            reduce using rule 32 (binary_op -> expression GT expression .)
    DO              reduce using rule 32 (binary_op -> expression GT expression .)
    COMMA           reduce using rule 32 (binary_op -> expression GT expression .)
    RBRACE          reduce using rule 32 (binary_op -> expression GT expression .)

  ! EQ              [ shift and go to state 40 ]
  ! NE              [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! DOT             [ shift and go to state 48 ]


state 68

    (33) binary_op -> expression GE expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            reduce using rule 33 (binary_op -> expression GE expression .)
    EQ              reduce using rule 33 (binary_op -> expression GE expression .)
    NE              reduce using rule 33 (binary_op -> expression GE expression .)
    LT              reduce using rule 33 (binary_op -> expression GE expression .)
    LE              reduce using rule 33 (binary_op -> expression GE expression .)
    GT              reduce using rule 33 (binary_op -> expression GE expression .)
    GE              reduce using rule 33 (binary_op -> expression GE expression .)
    AND             reduce using rule 33 (binary_op -> expression GE expression .)
    OR              reduce using rule 33 (binary_op -> expression GE expression .)
    DOT             reduce using rule 33 (binary_op -> expression GE expression .)
    RPAREN          reduce using rule 33 (binary_op -> expression GE expression .)
    LET             reduce using rule 33 (binary_op -> expression GE expression .)
    CALL            reduce using rule 33 (binary_op -> expression GE expression .)
    IF              reduce using rule 33 (binary_op -> expression GE expression .)
    FOR             reduce using rule 33 (binary_op -> expression GE expression .)
    NOW             reduce using rule 33 (binary_op -> expression GE expression .)
    PRINT           reduce using rule 33 (binary_op -> expression GE expression .)
    $end            reduce using rule 33 (binary_op -> expression GE expression .)
    END             reduce using rule 33 (binary_op -> expression GE expression .)
    ELSE            reduce using rule 33 (binary_op -> expression GE expression .)
    DO              reduce using rule 33 (binary_op -> expression GE expression .)
    COMMA           reduce using rule 33 (binary_op -> expression GE expression .)
    RBRACE          reduce using rule 33 (binary_op -> expression GE expression .)

  ! EQ              [ shift and go to state 40 ]
  ! NE              [ shift and go to state 41 ]
  ! LT              [ shift and go to state 42 ]
  ! LE              [ shift and go to state 43 ]
  ! GT              [ shift and go to state 44 ]
  ! GE              [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! DOT             [ shift and go to state 48 ]


state 69

    (34) binary_op -> expression AND expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            reduce using rule 34 (binary_op -> expression AND expression .)
    AND             reduce using rule 34 (binary_op -> expression AND expression .)
    OR              reduce using rule 34 (binary_op -> expression AND expression .)
    DOT             reduce using rule 34 (binary_op -> expression AND expression .)
    RPAREN          reduce using rule 34 (binary_op -> expression AND expression .)
    LET             reduce using rule 34 (binary_op -> expression AND expression .)
    CALL            reduce using rule 34 (binary_op -> expression AND expression .)
    IF              reduce using rule 34 (binary_op -> expression AND expression .)
    FOR             reduce using rule 34 (binary_op -> expression AND expression .)
    NOW             reduce using rule 34 (binary_op -> expression AND expression .)
    PRINT           reduce using rule 34 (binary_op -> expression AND expression .)
    $end            reduce using rule 34 (binary_op -> expression AND expression .)
    END             reduce using rule 34 (binary_op -> expression AND expression .)
    ELSE            reduce using rule 34 (binary_op -> expression AND expression .)
    DO              reduce using rule 34 (binary_op -> expression AND expression .)
    COMMA           reduce using rule 34 (binary_op -> expression AND expression .)
    RBRACE          reduce using rule 34 (binary_op -> expression AND expression .)
    EQ              shift and go to state 40
    NE              shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45

  ! EQ              [ reduce using rule 34 (binary_op -> expression AND expression .) ]
  ! NE              [ reduce using rule 34 (binary_op -> expression AND expression .) ]
  ! LT              [ reduce using rule 34 (binary_op -> expression AND expression .) ]
  ! LE              [ reduce using rule 34 (binary_op -> expression AND expression .) ]
  ! GT              [ reduce using rule 34 (binary_op -> expression AND expression .) ]
  ! GE              [ reduce using rule 34 (binary_op -> expression AND expression .) ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! DOT             [ shift and go to state 48 ]


state 70

    (35) binary_op -> expression OR expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    THEN            reduce using rule 35 (binary_op -> expression OR expression .)
    OR              reduce using rule 35 (binary_op -> expression OR expression .)
    DOT             reduce using rule 35 (binary_op -> expression OR expression .)
    RPAREN          reduce using rule 35 (binary_op -> expression OR expression .)
    LET             reduce using rule 35 (binary_op -> expression OR expression .)
    CALL            reduce using rule 35 (binary_op -> expression OR expression .)
    IF              reduce using rule 35 (binary_op -> expression OR expression .)
    FOR             reduce using rule 35 (binary_op -> expression OR expression .)
    NOW             reduce using rule 35 (binary_op -> expression OR expression .)
    PRINT           reduce using rule 35 (binary_op -> expression OR expression .)
    $end            reduce using rule 35 (binary_op -> expression OR expression .)
    END             reduce using rule 35 (binary_op -> expression OR expression .)
    ELSE            reduce using rule 35 (binary_op -> expression OR expression .)
    DO              reduce using rule 35 (binary_op -> expression OR expression .)
    COMMA           reduce using rule 35 (binary_op -> expression OR expression .)
    RBRACE          reduce using rule 35 (binary_op -> expression OR expression .)
    EQ              shift and go to state 40
    NE              shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    AND             shift and go to state 46

  ! EQ              [ reduce using rule 35 (binary_op -> expression OR expression .) ]
  ! NE              [ reduce using rule 35 (binary_op -> expression OR expression .) ]
  ! LT              [ reduce using rule 35 (binary_op -> expression OR expression .) ]
  ! LE              [ reduce using rule 35 (binary_op -> expression OR expression .) ]
  ! GT              [ reduce using rule 35 (binary_op -> expression OR expression .) ]
  ! GE              [ reduce using rule 35 (binary_op -> expression OR expression .) ]
  ! AND             [ reduce using rule 35 (binary_op -> expression OR expression .) ]
  ! OR              [ shift and go to state 47 ]
  ! DOT             [ shift and go to state 48 ]


state 71

    (36) binary_op -> expression DOT ID .

    THEN            reduce using rule 36 (binary_op -> expression DOT ID .)
    EQ              reduce using rule 36 (binary_op -> expression DOT ID .)
    NE              reduce using rule 36 (binary_op -> expression DOT ID .)
    LT              reduce using rule 36 (binary_op -> expression DOT ID .)
    LE              reduce using rule 36 (binary_op -> expression DOT ID .)
    GT              reduce using rule 36 (binary_op -> expression DOT ID .)
    GE              reduce using rule 36 (binary_op -> expression DOT ID .)
    AND             reduce using rule 36 (binary_op -> expression DOT ID .)
    OR              reduce using rule 36 (binary_op -> expression DOT ID .)
    DOT             reduce using rule 36 (binary_op -> expression DOT ID .)
    RPAREN          reduce using rule 36 (binary_op -> expression DOT ID .)
    LET             reduce using rule 36 (binary_op -> expression DOT ID .)
    CALL            reduce using rule 36 (binary_op -> expression DOT ID .)
    IF              reduce using rule 36 (binary_op -> expression DOT ID .)
    FOR             reduce using rule 36 (binary_op -> expression DOT ID .)
    NOW             reduce using rule 36 (binary_op -> expression DOT ID .)
    PRINT           reduce using rule 36 (binary_op -> expression DOT ID .)
    $end            reduce using rule 36 (binary_op -> expression DOT ID .)
    END             reduce using rule 36 (binary_op -> expression DOT ID .)
    ELSE            reduce using rule 36 (binary_op -> expression DOT ID .)
    DO              reduce using rule 36 (binary_op -> expression DOT ID .)
    COMMA           reduce using rule 36 (binary_op -> expression DOT ID .)
    RBRACE          reduce using rule 36 (binary_op -> expression DOT ID .)


state 72

    (27) expression -> LPAREN expression RPAREN .

    THEN            reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    DOT             reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    LET             reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    CALL            reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    FOR             reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    NOW             reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    PRINT           reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    END             reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    DO              reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 27 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 27 (expression -> LPAREN expression RPAREN .)


state 73

    (40) call_expression -> CALL ID LBRACE . arguments RBRACE
    (14) arguments -> . argument_list
    (15) arguments -> . empty
    (16) argument_list -> . argument_list COMMA argument
    (17) argument_list -> . argument
    (19) empty -> .
    (18) argument -> . ID COLON expression

    RBRACE          reduce using rule 19 (empty -> .)
    ID              shift and go to state 57

    arguments                      shift and go to state 83
    argument_list                  shift and go to state 59
    empty                          shift and go to state 60
    argument                       shift and go to state 61

state 74

    (41) calc_expression -> CALC LBRACE calc_args . RBRACE

    RBRACE          shift and go to state 84


state 75

    (42) calc_args -> ID . COLON STRING COMMA ID COLON LBRACE arguments RBRACE

    COLON           shift and go to state 85


state 76

    (13) for_statement -> FOR ID IN expression . DO statements END
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    DO              shift and go to state 86
    EQ              shift and go to state 40
    NE              shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    DOT             shift and go to state 48


state 77

    (39) function_call -> PRINT LPAREN expression RPAREN .

    LET             reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    CALL            reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    IF              reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    FOR             reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    NOW             reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    PRINT           reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    THEN            reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    EQ              reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    NE              reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    LT              reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    LE              reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    GT              reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    GE              reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    AND             reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    OR              reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    DOT             reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    RPAREN          reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    END             reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    ELSE            reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    DO              reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    COMMA           reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)
    RBRACE          reduce using rule 39 (function_call -> PRINT LPAREN expression RPAREN .)


state 78

    (18) argument -> ID COLON . expression
    (20) expression -> . binary_op
    (21) expression -> . unary_op
    (22) expression -> . function_call
    (23) expression -> . call_expression
    (24) expression -> . calc_expression
    (25) expression -> . literal
    (26) expression -> . variable
    (27) expression -> . LPAREN expression RPAREN
    (28) binary_op -> . expression EQ expression
    (29) binary_op -> . expression NE expression
    (30) binary_op -> . expression LT expression
    (31) binary_op -> . expression LE expression
    (32) binary_op -> . expression GT expression
    (33) binary_op -> . expression GE expression
    (34) binary_op -> . expression AND expression
    (35) binary_op -> . expression OR expression
    (36) binary_op -> . expression DOT ID
    (37) unary_op -> . NOT expression
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN
    (40) call_expression -> . CALL ID LBRACE arguments RBRACE
    (41) calc_expression -> . CALC LBRACE calc_args RBRACE
    (43) literal -> . NUMBER
    (44) literal -> . STRING
    (45) literal -> . BOOLEAN
    (46) variable -> . ID

    LPAREN          shift and go to state 26
    NOT             shift and go to state 28
    NOW             shift and go to state 13
    PRINT           shift and go to state 14
    CALL            shift and go to state 29
    CALC            shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    BOOLEAN         shift and go to state 33
    ID              shift and go to state 27

    expression                     shift and go to state 87
    binary_op                      shift and go to state 19
    unary_op                       shift and go to state 20
    function_call                  shift and go to state 21
    call_expression                shift and go to state 22
    calc_expression                shift and go to state 23
    literal                        shift and go to state 24
    variable                       shift and go to state 25

state 79

    (10) call_statement -> CALL ID LBRACE arguments RBRACE .

    LET             reduce using rule 10 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    CALL            reduce using rule 10 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    IF              reduce using rule 10 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    FOR             reduce using rule 10 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    NOW             reduce using rule 10 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    PRINT           reduce using rule 10 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    $end            reduce using rule 10 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    END             reduce using rule 10 (call_statement -> CALL ID LBRACE arguments RBRACE .)
    ELSE            reduce using rule 10 (call_statement -> CALL ID LBRACE arguments RBRACE .)


state 80

    (16) argument_list -> argument_list COMMA . argument
    (18) argument -> . ID COLON expression

    ID              shift and go to state 57

    argument                       shift and go to state 88

state 81

    (11) if_statement -> IF expression THEN statements END .

    LET             reduce using rule 11 (if_statement -> IF expression THEN statements END .)
    CALL            reduce using rule 11 (if_statement -> IF expression THEN statements END .)
    IF              reduce using rule 11 (if_statement -> IF expression THEN statements END .)
    FOR             reduce using rule 11 (if_statement -> IF expression THEN statements END .)
    NOW             reduce using rule 11 (if_statement -> IF expression THEN statements END .)
    PRINT           reduce using rule 11 (if_statement -> IF expression THEN statements END .)
    $end            reduce using rule 11 (if_statement -> IF expression THEN statements END .)
    END             reduce using rule 11 (if_statement -> IF expression THEN statements END .)
    ELSE            reduce using rule 11 (if_statement -> IF expression THEN statements END .)


state 82

    (12) if_statement -> IF expression THEN statements ELSE . statements END
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) statement -> . function_call
    (9) let_statement -> . LET ID ASSIGN expression
    (10) call_statement -> . CALL ID LBRACE arguments RBRACE
    (11) if_statement -> . IF expression THEN statements END
    (12) if_statement -> . IF expression THEN statements ELSE statements END
    (13) for_statement -> . FOR ID IN expression DO statements END
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN

    LET             shift and go to state 9
    CALL            shift and go to state 10
    IF              shift and go to state 11
    FOR             shift and go to state 12
    NOW             shift and go to state 13
    PRINT           shift and go to state 14

    statements                     shift and go to state 89
    statement                      shift and go to state 3
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7
    function_call                  shift and go to state 8

state 83

    (40) call_expression -> CALL ID LBRACE arguments . RBRACE

    RBRACE          shift and go to state 90


state 84

    (41) calc_expression -> CALC LBRACE calc_args RBRACE .

    THEN            reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    EQ              reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    NE              reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    LT              reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    LE              reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    GT              reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    GE              reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    AND             reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    OR              reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    DOT             reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    RPAREN          reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    LET             reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    CALL            reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    IF              reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    FOR             reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    NOW             reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    PRINT           reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    $end            reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    END             reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    ELSE            reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    DO              reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    COMMA           reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)
    RBRACE          reduce using rule 41 (calc_expression -> CALC LBRACE calc_args RBRACE .)


state 85

    (42) calc_args -> ID COLON . STRING COMMA ID COLON LBRACE arguments RBRACE

    STRING          shift and go to state 91


state 86

    (13) for_statement -> FOR ID IN expression DO . statements END
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) statement -> . function_call
    (9) let_statement -> . LET ID ASSIGN expression
    (10) call_statement -> . CALL ID LBRACE arguments RBRACE
    (11) if_statement -> . IF expression THEN statements END
    (12) if_statement -> . IF expression THEN statements ELSE statements END
    (13) for_statement -> . FOR ID IN expression DO statements END
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN

    LET             shift and go to state 9
    CALL            shift and go to state 10
    IF              shift and go to state 11
    FOR             shift and go to state 12
    NOW             shift and go to state 13
    PRINT           shift and go to state 14

    statements                     shift and go to state 92
    statement                      shift and go to state 3
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7
    function_call                  shift and go to state 8

state 87

    (18) argument -> ID COLON expression .
    (28) binary_op -> expression . EQ expression
    (29) binary_op -> expression . NE expression
    (30) binary_op -> expression . LT expression
    (31) binary_op -> expression . LE expression
    (32) binary_op -> expression . GT expression
    (33) binary_op -> expression . GE expression
    (34) binary_op -> expression . AND expression
    (35) binary_op -> expression . OR expression
    (36) binary_op -> expression . DOT ID

    COMMA           reduce using rule 18 (argument -> ID COLON expression .)
    RBRACE          reduce using rule 18 (argument -> ID COLON expression .)
    EQ              shift and go to state 40
    NE              shift and go to state 41
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    DOT             shift and go to state 48


state 88

    (16) argument_list -> argument_list COMMA argument .

    COMMA           reduce using rule 16 (argument_list -> argument_list COMMA argument .)
    RBRACE          reduce using rule 16 (argument_list -> argument_list COMMA argument .)


state 89

    (12) if_statement -> IF expression THEN statements ELSE statements . END
    (2) statements -> statements . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) statement -> . function_call
    (9) let_statement -> . LET ID ASSIGN expression
    (10) call_statement -> . CALL ID LBRACE arguments RBRACE
    (11) if_statement -> . IF expression THEN statements END
    (12) if_statement -> . IF expression THEN statements ELSE statements END
    (13) for_statement -> . FOR ID IN expression DO statements END
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN

    END             shift and go to state 93
    LET             shift and go to state 9
    CALL            shift and go to state 10
    IF              shift and go to state 11
    FOR             shift and go to state 12
    NOW             shift and go to state 13
    PRINT           shift and go to state 14

    statement                      shift and go to state 15
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7
    function_call                  shift and go to state 8

state 90

    (40) call_expression -> CALL ID LBRACE arguments RBRACE .

    THEN            reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    EQ              reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    NE              reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    LT              reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    LE              reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    GT              reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    GE              reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    AND             reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    OR              reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    DOT             reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    RPAREN          reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    LET             reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    CALL            reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    IF              reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    FOR             reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    NOW             reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    PRINT           reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    $end            reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    END             reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    ELSE            reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    DO              reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    COMMA           reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)
    RBRACE          reduce using rule 40 (call_expression -> CALL ID LBRACE arguments RBRACE .)


state 91

    (42) calc_args -> ID COLON STRING . COMMA ID COLON LBRACE arguments RBRACE

    COMMA           shift and go to state 94


state 92

    (13) for_statement -> FOR ID IN expression DO statements . END
    (2) statements -> statements . statement
    (4) statement -> . let_statement
    (5) statement -> . call_statement
    (6) statement -> . if_statement
    (7) statement -> . for_statement
    (8) statement -> . function_call
    (9) let_statement -> . LET ID ASSIGN expression
    (10) call_statement -> . CALL ID LBRACE arguments RBRACE
    (11) if_statement -> . IF expression THEN statements END
    (12) if_statement -> . IF expression THEN statements ELSE statements END
    (13) for_statement -> . FOR ID IN expression DO statements END
    (38) function_call -> . NOW LPAREN RPAREN
    (39) function_call -> . PRINT LPAREN expression RPAREN

    END             shift and go to state 95
    LET             shift and go to state 9
    CALL            shift and go to state 10
    IF              shift and go to state 11
    FOR             shift and go to state 12
    NOW             shift and go to state 13
    PRINT           shift and go to state 14

    statement                      shift and go to state 15
    let_statement                  shift and go to state 4
    call_statement                 shift and go to state 5
    if_statement                   shift and go to state 6
    for_statement                  shift and go to state 7
    function_call                  shift and go to state 8

state 93

    (12) if_statement -> IF expression THEN statements ELSE statements END .

    LET             reduce using rule 12 (if_statement -> IF expression THEN statements ELSE statements END .)
    CALL            reduce using rule 12 (if_statement -> IF expression THEN statements ELSE statements END .)
    IF              reduce using rule 12 (if_statement -> IF expression THEN statements ELSE statements END .)
    FOR             reduce using rule 12 (if_statement -> IF expression THEN statements ELSE statements END .)
    NOW             reduce using rule 12 (if_statement -> IF expression THEN statements ELSE statements END .)
    PRINT           reduce using rule 12 (if_statement -> IF expression THEN statements ELSE statements END .)
    $end            reduce using rule 12 (if_statement -> IF expression THEN statements ELSE statements END .)
    END             reduce using rule 12 (if_statement -> IF expression THEN statements ELSE statements END .)
    ELSE            reduce using rule 12 (if_statement -> IF expression THEN statements ELSE statements END .)


state 94

    (42) calc_args -> ID COLON STRING COMMA . ID COLON LBRACE arguments RBRACE

    ID              shift and go to state 96


state 95

    (13) for_statement -> FOR ID IN expression DO statements END .

    LET             reduce using rule 13 (for_statement -> FOR ID IN expression DO statements END .)
    CALL            reduce using rule 13 (for_statement -> FOR ID IN expression DO statements END .)
    IF              reduce using rule 13 (for_statement -> FOR ID IN expression DO statements END .)
    FOR             reduce using rule 13 (for_statement -> FOR ID IN expression DO statements END .)
    NOW             reduce using rule 13 (for_statement -> FOR ID IN expression DO statements END .)
    PRINT           reduce using rule 13 (for_statement -> FOR ID IN expression DO statements END .)
    $end            reduce using rule 13 (for_statement -> FOR ID IN expression DO statements END .)
    END             reduce using rule 13 (for_statement -> FOR ID IN expression DO statements END .)
    ELSE            reduce using rule 13 (for_statement -> FOR ID IN expression DO statements END .)


state 96

    (42) calc_args -> ID COLON STRING COMMA ID . COLON LBRACE arguments RBRACE

    COLON           shift and go to state 97


state 97

    (42) calc_args -> ID COLON STRING COMMA ID COLON . LBRACE arguments RBRACE

    LBRACE          shift and go to state 98


state 98

    (42) calc_args -> ID COLON STRING COMMA ID COLON LBRACE . arguments RBRACE
    (14) arguments -> . argument_list
    (15) arguments -> . empty
    (16) argument_list -> . argument_list COMMA argument
    (17) argument_list -> . argument
    (19) empty -> .
    (18) argument -> . ID COLON expression

    RBRACE          reduce using rule 19 (empty -> .)
    ID              shift and go to state 57

    arguments                      shift and go to state 99
    argument_list                  shift and go to state 59
    empty                          shift and go to state 60
    argument                       shift and go to state 61

state 99

    (42) calc_args -> ID COLON STRING COMMA ID COLON LBRACE arguments . RBRACE

    RBRACE          shift and go to state 100


state 100

    (42) calc_args -> ID COLON STRING COMMA ID COLON LBRACE arguments RBRACE .

    RBRACE          reduce using rule 42 (calc_args -> ID COLON STRING COMMA ID COLON LBRACE arguments RBRACE .)

