import { 
  stringToBytes, 
  sha3_256, 
  toHEX,
  Serializer,
} from '@roochnetwork/rooch-sdk';
import { resolveDidObjectID, DIDDocumentStructTag } from '../roochVDRTypes';


// #[test_only]
//     struct TestStructID has store, copy, drop {
//         id: u64,
//     }

//     #[test]
//     fun test_custom_object_id() {
//         let id = TestStructID { id: 1 };
//         let object_id = custom_object_id<TestStructID, TestStruct>(id);
//         //ensure the object_id is the same as the object_id generated by the object.rs
//         assert!(object_id.path == vector[@0x6c62fde28fadbe652ba0eec95f5f096c900c94191a2debca96276b2de4b6ee3a], 1);
//     }
describe('roochVDRTypes', () => {
  it('should resolve custom object ID correctly', () => {
    const testStructTag = {
        address: '0x2',
        module: 'object',
        name: 'TestStruct',
        typeParams: [],
    }
    
    const identifier = '1';
    const objectId = resolveDidObjectID(identifier);
    
    // Convert identifier to bytes
    const idBytes = stringToBytes('utf8', identifier);
    
    // Get the canonical string representation of the struct tag
    const typeStr = Serializer.structTagToCanonicalString(DIDDocumentStructTag);
    const typeBytes = stringToBytes('utf8', typeStr);
    
    // Combine bytes
    const bytes = new Uint8Array(idBytes.length + typeBytes.length);
    bytes.set(idBytes);
    bytes.set(typeBytes, idBytes.length);
    
    // Calculate expected hash
    const hash = sha3_256(bytes);
    const expectedObjectId = `0x${toHEX(hash)}`;
    
    // Assert the result matches the expected value
    expect(objectId).toBe(expectedObjectId);

    // The hash value should be deterministic
    // We can add a known hash value here for regression testing
    // This is similar to the test case in object.move
    expect(objectId).toBe('0x6c62fde28fadbe652ba0eec95f5f096c900c94191a2debca96276b2de4b6ee3a');
  });
}); 